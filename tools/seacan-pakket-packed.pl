#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Dancer2/Plugin/Pakket/ParamTypes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_PLUGIN_PAKKET_PARAMTYPES';
  package Dancer2::Plugin::Pakket::ParamTypes;
  # ABSTRACT: Parameter types for the Dancer2 Pakket app
  
  use strict;
  use warnings;
  use constant { 'HTTP_USER_ERROR' => 400 };
  use Dancer2::Plugin;
  
  extends('Dancer2::Plugin::ParamTypes');
  plugin_keywords('with_types');
  
  sub with_types {
      my $self = shift;
      return $self->SUPER::with_types(@_);
  }
  
  sub BUILD {
      my $self = shift;
  
      $self->register_type_check(
          'Str' => sub { defined $_[0] && length $_[0] },
      );
  
      $self->register_type_action(
          'MissingID' => sub {
              send_error( 'Missing or incorrect ID', HTTP_USER_ERROR() );
          },
      );
  
      $self->register_type_action(
          'MissingContent' => sub {
              send_error( 'Missing or incorrect content', HTTP_USER_ERROR() );
          },
      );
  
      $self->register_type_action(
          'MissingFilename' => sub {
              send_error( 'Missing or incorrect filename', HTTP_USER_ERROR() );
          },
      );
  }
  
  1;
DANCER2_PLUGIN_PAKKET_PARAMTYPES

$fatpacked{"Pakket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET';
  package Pakket;
  # ABSTRACT: An Unopinionated Meta-Packaging System
  
  use strict;
  use warnings;
  
  1;
  
  __END__
  
  =pod
  
  =head1 DESCRIPTION
  
  Pakket is a meta-packaging system that allows you to manage your system
  dependencies. It works by trying to avoid work.
  
  =head2 What can you do with Pakket?
  
  =over 4
  
  =item * You can represent packages closer to their true nature
  
  Unlike most packaging systems, Pakket works to I<avoid> reducing the
  complexity of packages. Instead of trying to take away what makes each
  package unique, Pakket tries to make it possible for packages to retain
  the information relevant to them.
  
  One example of this is that different systems use different versioning
  schemes, which can confuse packaging systems, not knowing which version
  is older and which is newer.
  
  Packages in Pakket can keep their version number, the way they see it.
  That's just one example, though.
  
  =item * You can connect different packages
  
  Package systems designed specifically for, say Node.js, cannot connect
  their packages with C dependencies or with Perl dependencies. C programs
  do not have a packaging system, so C "packages" cannot be connected with
  anything.
  
  Because Pakket knows these packages, it can connect them together, even
  if their own systems can't.
  
  If you have a Perl binding to a C++ library, you can represent that
  relationship in Pakket. Pakket will then know how to build the C++
  library and build your Perl module binding to that C++ library.
  
  =item * You can build packages for delivery
  
  Pakket builds simple package files that can then be delivered to a
  different machine and used there. While you I<should> use the Pakket
  installer to deal with these packages, you can also open them up
  yourself; no magic here.
  
  =item * You can install packages
  
  The Pakket installer allows installing a package and its dependencies
  recursively, from disk or mirrors, and to manage your installation tree.
  
  =item * Atomic installations, oh yeah
  
  Did we mention all installations in Pakket are atomic? This means that
  if you're installing 20 or 20,000 packages and it fails, everything
  still works. Pakket only activates the new installation once it finished
  everything.
  
  =item * Reverts are also atomic, baby!
  
  The Pakket installer allows, by default, to retain multiple
  installation directories. This means any revert is simply a single
  atomic operation of pointing to an older installation.
  
  =item * Multiple instances
  
  Most packaging systems can only work with a single installation of a
  package for the entire system. If you need another copy of a package
  (same version or a different version), you either can't do it, or the
  packaging system must create a new package with a name that contains the
  version (python27, python3, etc.).
  
  Pakket considers any installation as a single installation instance. You
  can have as many installations of a package as you want. There can be a
  global one, a per-user one, a local directory one, a project-specific
  one, etc.; your pick. You can use one or more than one.
  
  =back
  
  =head2 Pakket elements
  
  Pakket has several key elements:
  
  =head3 Packages
  
  Everything you wish to build and install is a package. A package
  can be a program in your favorite language, a library of a language,
  or anything at all. It will go through a build process you pick and
  it will get bundled into a parcel.
  
  =head3 Categories
  
  All packages have a category. Unlike other systems, Pakket doesn't
  have a flat structure of packages. They're split into categories.
  
  The category of a package tells Pakket what kind of build system it
  needs, how to retrieve metadata from the sources, and what to do
  with it.
  
  For example, packages in the B<perl> category tell Pakket that the
  builder will need to use one of the available build systems for
  a Perl module (such as C<ExtUtils::MakeMaker> or C<Module::Build>).
  It will also use the versioning scheme that Perl has in order to
  decide which is a newer version and which is older.
  
  =head3 Requirements
  
  Pakket makes a difference between a package and a requirement. A package
  is an existing instance; a requirement is a description. The requirement
  can have a range of allowed versions for a package, for example.
  
  =head3 Spec files
  
  Similar to RPM spec files, Pakket has spec files. You can create them
  yourself or you can use the L<generate|Pakket::CLI::Command::generate>
  command to create them for you.
  
  The basic spec file in Pakket contain a package's C<category>,
  C<name>, and C<version>. It usually contains C<prereqs> as well,
  keyed by the B<category> and the B<phase>. The phases can be
  B<configure> (for build-time), B<test> (for when testing the build),
  and B<runtime> (for using it).
  
  At the moment Pakket keeps its specs in JSON files.
  
  An example of a spec in Pakket:
  
      {
         "Package" : {
            "category" : "perl",
            "name" : "HTML-Tidy",
            "version" : "1.56"
         },
         "Prereqs" : {
            "native" : {
               "configure" : {
                  "tidyp" : {
                     "version" : "1.04"
                  }
               }
            },
            "perl" : {
               "configure" : {
                  "ExtUtils-MakeMaker" : {
                     "version" : "7.24"
                  }
               },
               "runtime" : {
                  "Test-Simple" : {
                     "version" : "1.302031"
                  }
               }
            }
         }
      }
  
  The package details are in the C<Package> section. The prereqs are
  in the C<Prereqs> section, under the C<native> or C<perl> categories,
  under the C<configure> or C<runtime> phase.
  
  =head3 Index
  
  The B<index> is where Pakket maintains all known versions of every
  package and their locations.
  
  One of the abilities Pakket gives you is maintaining multiple "trees"
  of systems, each needing different versions of each package.
  
  =head3 Parcels
  
  Parcels are the result of building packages. Parcels are what gets
  finally installed.
  
  While other packaging systems usually have I<development packages> (or
  I<devel> or I<dev>), Pakket doesn't differentiate between those.
  Instead, a Pakket package contains everything created at build time,
  including the headers and the compiled results.
PAKKET

$fatpacked{"Pakket/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER';
  package Pakket::Builder;
  # ABSTRACT: Build pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use List::Util                qw< first       >;
  use Path::Tiny                qw< path        >;
  use File::Copy::Recursive     qw< dircopy     >;
  use Algorithm::Diff::Callback qw< diff_hashes >;
  use Types::Path::Tiny         qw< Path >;
  use Log::Any                  qw< $log >;
  use version 0.77;
  
  use Pakket::Log qw< log_success log_fail >;
  use Pakket::Package;
  use Pakket::Bundler;
  use Pakket::Installer;
  use Pakket::Requirement;
  use Pakket::Builder::NodeJS;
  use Pakket::Builder::Perl;
  use Pakket::Builder::Native;
  
  use Pakket::Utils qw< generate_env_vars >;
  
  use constant {
      'BUILD_DIR_TEMPLATE' => 'BUILD-XXXXXX',
  };
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasSpecRepo
      Pakket::Role::HasSourceRepo
      Pakket::Role::HasParcelRepo
      Pakket::Role::Perl::BootstrapModules
      Pakket::Role::RunCommand
  >;
  
  has 'build_dir' => (
      'is'      => 'ro',
      'isa'     => Path,
      'coerce'  => 1,
      'lazy'    => 1,
      'default' => sub {
          return Path::Tiny->tempdir(
              BUILD_DIR_TEMPLATE(),
              'CLEANUP' => 0,
          );
      },
  );
  
  has 'keep_build_dir' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {0},
  );
  
  has 'is_built' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'build_files_manifest' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'builders' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          return {
              'nodejs' => Pakket::Builder::NodeJS->new(),
              'perl'   => Pakket::Builder::Perl->new(),
              'native' => Pakket::Builder::Native->new(),
          };
      },
  );
  
  has 'bundler' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Bundler',
      'lazy'    => 1,
      'builder' => '_build_bundler',
  );
  
  has 'installer' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Installer',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          return Pakket::Installer->new(
              'pakket_dir'  => $self->build_dir,
              'parcel_repo' => $self->parcel_repo,
          );
      },
  );
  
  has 'installer_cache' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'bootstrapping' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => 1,
  );
  
  sub _build_bundler {
      my $self = shift;
  
      return Pakket::Bundler->new(
          'parcel_repo' => $self->parcel_repo,
      );
  }
  
  sub build {
      my ( $self, @requirements ) = @_;
      my %categories = map +( $_->category => 1 ), @requirements;
  
      $self->_setup_build_dir;
  
      if ( $self->bootstrapping ) {
          foreach my $category ( keys %categories ) {
              $self->bootstrap_build($category);
              log_success('Bootstrapping');
          }
      }
  
      foreach my $requirement (@requirements ) {
          $self->run_build($requirement);
      }
  }
  
  sub DEMOLISH {
      my $self      = shift;
      my $build_dir = $self->build_dir;
  
      if ( !$self->keep_build_dir ) {
          $log->debug("Removing build dir $build_dir");
  
          # "safe" is false because it might hit files which it does not have
          # proper permissions to delete (example: ZMQ::Constants.3pm)
          # which means it won't be able to remove the directory
          $build_dir->remove_tree( { 'safe' => 0 } );
      }
  
      return;
  }
  
  sub _setup_build_dir {
      my $self = shift;
  
      $log->debugf( 'Creating build dir %s', $self->build_dir->stringify );
      my $prefix_dir = $self->build_dir->child('main');
  
      $prefix_dir->is_dir or $prefix_dir->mkpath;
  
      return;
  }
  
  sub bootstrap_build {
      my ( $self, $category ) = @_;
  
      my @dists =
          $category eq 'perl' ? @{ $self->perl_bootstrap_modules } :
          # add more categories here
          ();
  
      @dists or return;
  
      ## no critic qw(BuiltinFunctions::ProhibitComplexMappings Lax::ProhibitComplexMappings::LinesNotStatements)
      my %dist_reqs = map {;
          my $name    = $_;
          my $ver_rel = $self->spec_repo->latest_version_release(
              $category, $name,
          );
          my ( $version, $release ) = @{$ver_rel};
  
          $name => Pakket::Requirement->new(
              'name'     => $name,
              'category' => $category,
              'version'  => $version,
              'release'  => $release,
          );
      } @dists;
  
      foreach my $dist_name ( @dists ) {
          my $dist_req = $dist_reqs{$dist_name};
  
          $self->parcel_repo->has_object($dist_req)
              or next;
  
          $log->debugf(
              'Skipping: parcel %s already exists',
              $dist_req->full_name,
          );
  
          delete $dist_reqs{$dist_name};
      }
  
      # Pass I: bootstrap toolchain - build w/o dependencies
      for my $dist_name ( @dists ) {
          my $dist_req = $dist_reqs{$dist_name};
  
          $log->debugf( 'Bootstrapping: phase I: %s (%s)',
                         $dist_req->full_name, 'no-deps' );
  
          $self->run_build(
              $dist_req,
              { 'bootstrapping_1_skip_prereqs' => 1 },
          );
      }
  
      # Pass II: bootstrap toolchain - build dependencies only
      for my $dist_name ( @dists ) {
          my $dist_req = $dist_reqs{$dist_name};
  
          $log->debugf( 'Bootstrapping: phase II: %s (%s)',
                         $dist_req->full_name, 'deps-only' );
  
          $self->run_build(
              $dist_req,
              { 'bootstrapping_2_deps_only' => 1 },
          );
      }
  
      # Pass III: bootstrap toolchain - rebuild w/ dependencies
      # XXX: Whoa!
      my $bootstrap_builder = ref($self)->new(
          'parcel_repo'    => $self->parcel_repo,
          'spec_repo'      => $self->spec_repo,
          'source_repo'    => $self->source_repo,
          'keep_build_dir' => $self->keep_build_dir,
          'builders'       => $self->builders,
          'installer'      => $self->installer,
          'bootstrapping'  => 0,
      );
  
      for my $dist_name ( @dists ) {
          my $dist_req = $dist_reqs{$dist_name};
  
          # remove the temp (no-deps) parcel
          $log->debugf( 'Removing %s (no-deps parcel)',
                         $dist_req->full_name );
  
          $self->parcel_repo->remove_package_parcel($dist_req);
  
          # build again with dependencies
  
          $log->debugf( 'Bootstrapping: phase III: %s (%s)',
                         $dist_req->full_name, 'full deps' );
  
          $bootstrap_builder->build($dist_req);
      }
  }
  
  sub run_build {
      my ( $self, $prereq, $params ) = @_;
      $params //= {};
      my $level             = $params->{'level'}                        || 0;
      my $skip_prereqs      = $params->{'bootstrapping_1_skip_prereqs'} || 0;
      my $bootstrap_prereqs = $params->{'bootstrapping_2_deps_only'}    || 0;
      my $short_name        = $prereq->short_name;
  
      # FIXME: GH #29
      if ( $prereq->category eq 'perl' ) {
          # XXX: perl_mlb is a MetaCPAN bug
          first { $prereq->name eq $_ } qw<perl perl_mlb>
              and return;
      }
  
      if ( ! $bootstrap_prereqs and defined $self->is_built->{$short_name} ) {
          my $ver_rel = $self->is_built->{$short_name};
          my ( $built_version, $built_release ) = @{$ver_rel};
  
          # Check the versions mismatch
          if ( $built_version ne $prereq->version ) {
              die $log->criticalf(
                  'Asked to build %s when %s=%s already built',
                  $prereq->full_name, $short_name, $built_version,
              );
          }
  
          # Check the releases mismatch
          if ( $built_release ne $prereq->release ) {
              die $log->criticalf(
                  'Asked to build %s when %s=%s:%s already built',
                  $prereq->full_name, $short_name, $built_version, $built_release,
              );
          }
  
          $log->debug(
              "We already built or building $short_name, skipping...",
          );
  
          return;
      } else {
          $self->is_built->{$short_name} = [
              $prereq->version,
              $prereq->release,
          ];
      }
  
      # TODO: indent to $level
      $log->debugf( 'Working on %s', $prereq->full_name );
  
      # Create a Package instance from the spec
      # using the information we have on it
      my $package_spec = $self->spec_repo->retrieve_package_spec($prereq);
      my $package      = Pakket::Package->new_from_spec( +{
          %{$package_spec},
  
          # We are dealing with a version which should not be installed
          # outside of a bootstrap phase, so we're "marking" this package
          'is_bootstrap' => !!$skip_prereqs,
      } );
  
      my $top_build_dir  = $self->build_dir;
      my $main_build_dir = $top_build_dir->child('main');
  
      my $installer = $self->installer;
  
      if ( !$skip_prereqs && !$bootstrap_prereqs ) {
          my $installer_cache = $self->installer_cache;
          my $bootstrap_cache = {
              %{ $self->installer_cache },
  
              # Phase 3 needs to avoid trying to install
              # the bare minimum toolchain (Phase 1)
              $prereq->category => { $package->name => $package->version },
          };
  
          my $successfully_installed = $installer->try_to_install_package(
              $package,
              $main_build_dir,
              {
                  'cache'        => ( $self->bootstrapping ? $installer_cache : $bootstrap_cache ),
                  'skip_prereqs' => $skip_prereqs,
              },
          );
  
          if ($successfully_installed) {
  
              # snapshot_build_dir
              $self->snapshot_build_dir( $package, $main_build_dir->absolute, 0 );
  
              # TODO: indent to $level
              $log->debugf( 'Installed %s', $prereq->full_name );
  
              # sync build cache with our install cache
              # so we do not accidentally build things
              # that were installed in some recursive iteration
              foreach my $category ( sort keys %{$installer_cache} ) {
                  foreach my $package_name (
                      keys %{ $installer_cache->{$category} } )
                  {
                      $self->is_built->{"$category/$package_name"}
                          = $installer_cache->{$category}{$package_name};
                  }
              }
  
              return;
          }
      }
  
      # recursively build prereqs
      # FIXME: GH #74
      if ( $bootstrap_prereqs or ! $skip_prereqs ) {
          foreach my $category ( keys %{ $self->builders } ) {
              $self->_recursive_build_phase( $package, $category, 'configure', $level+1 );
              $self->_recursive_build_phase( $package, $category, 'runtime', $level+1 );
          }
      }
  
      $bootstrap_prereqs and return; # done building prereqs
      my $package_src_dir
          = $self->source_repo->retrieve_package_source($package);
  
      $log->debug('Copying package files');
  
      # FIXME: we shouldn't be generating PKG_CONFIG_PATH every time
      #        Instead, set this as default opt and send it to the build
      #        subroutines as "default opts" to add their own stuff to
      #        and add LD_LIBRARY_PATH and PATH to this as well
      my $pkgconfig_path = $top_build_dir->child( qw<main lib pkgconfig> );
      $log->debug("Setting PKG_CONFIG_PATH=$pkgconfig_path");
      local $ENV{'PKG_CONFIG_PATH'} = $pkgconfig_path;
  
      # FIXME: This shouldn't just be configure flags
      # we should allow the builder to have access to a general
      # metadata chunk which *might* include configure flags
      my $configure_flags = $self->get_configure_flags(
          $package->build_opts->{'configure_flags'},
          { %ENV, generate_env_vars( $top_build_dir, $main_build_dir ) },
      );
  
      if ( my $builder = $self->builders->{ $package->category } ) {
          my $package_dst_dir = $top_build_dir->child(
              'src',
              $package->category,
              $package_src_dir->basename,
          );
  
  
          dircopy( $package_src_dir, $package_dst_dir );
  
          $builder->build_package(
              $package->name,
              $package_dst_dir,
              $main_build_dir,
              $configure_flags,
          );
      } else {
          die $log->criticalf(
              'I do not have a builder for category %s.',
              $package->category,
          );
      }
  
      my $package_files = $self->snapshot_build_dir(
          $package, $main_build_dir,
      );
  
      $log->debugf( 'Bundling %s', $package->full_name );
      $self->bundler->bundle(
          $main_build_dir->absolute,
          $package,
          $package_files,
      );
  
      # TODO: indent to $level
      $log->debugf( 'Finished on %s', $prereq->full_name );
      log_success( sprintf 'Building %s', $prereq->full_name );
  
      return;
  }
  
  sub _recursive_build_phase {
      my ( $self, $package, $category, $phase, $level ) = @_;
      my @prereqs = keys %{ $package->prereqs->{$category}{$phase} };
  
      foreach my $prereq_name (@prereqs) {
          my $prereq_ver_req =
              $package->prereqs->{$category}{$phase}{$prereq_name}{'version'};
  
          my $ver_rel = $self->spec_repo->latest_version_release(
              $category, $prereq_name, $prereq_ver_req,
          );
  
          my ( $version, $release ) = @{$ver_rel};
  
          my $req = Pakket::Requirement->new(
              'category' => $category,
              'name'     => $prereq_name,
              'version'  => $version,
              'release'  => $release,
          );
  
          $self->run_build( $req, { 'level' => $level } );
      }
  }
  
  sub snapshot_build_dir {
      my ( $self, $package, $main_build_dir, $error_out ) = @_;
      $error_out //= 1;
  
      $log->debug('Scanning directory.');
  
      # XXX: this is just a bit of a smarter && dumber rsync(1):
      # rsync -qaz BUILD/main/ output_dir/
      # the reason is that we need the diff.
      # if you can make it happen with rsync, remove all of this. :P
      # perhaps rsync(1) should be used to deploy the package files
      # (because then we want *all* content)
      # (only if unpacking it directly into the directory fails)
      my $package_files = $self->retrieve_new_files($main_build_dir);
  
      if ($error_out) {
          keys %{$package_files}
              or die $log->criticalf(
                  'This is odd. %s build did not generate new files. '
                      . 'Cannot package.',
                  $package->full_name,
              );
      }
  
      # store per all packages to get the diff
      @{ $self->build_files_manifest }{ keys( %{$package_files} ) }
          = values %{$package_files};
  
      return $package_files;
  }
  
  sub retrieve_new_files {
      my ( $self, $build_dir ) = @_;
  
      my $nodes = $self->_scan_directory($build_dir);
      my $new_files
          = $self->_diff_nodes_list( $self->build_files_manifest, $nodes, );
  
      return $new_files;
  }
  
  sub _scan_directory {
      my ( $self, $dir ) = @_;
  
      my $visitor = sub {
          my ( $node, $state ) = @_;
  
          return if $node->is_dir;
  
          # save the symlink path in order to symlink them
          if ( -l $node ) {
              path( $state->{ $node->absolute } = readlink $node )->is_absolute
                  and die $log->critical(
                      "Error. Absolute path symlinks aren't supported."
                  );
          } else {
              $state->{ $node->absolute } = '';
          }
      };
  
      return $dir->visit(
          $visitor,
          { 'recurse' => 1, 'follow_symlinks' => 0 },
      );
  }
  
  # There is a possible micro optimization gain here
  # if we diff and copy in the same loop
  # instead of two steps
  sub _diff_nodes_list {
      my ( $self, $old_nodes, $new_nodes ) = @_;
  
      my %nodes_diff;
      diff_hashes(
          $old_nodes,
          $new_nodes,
          'added'   => sub { $nodes_diff{ $_[0] } = $_[1] },
          'deleted' => sub {
              die $log->critical(
                  "Last build deleted previously existing file: $_[0]");
          },
      );
  
      return \%nodes_diff;
  }
  
  sub get_configure_flags {
      my ( $self, $config, $expand_env ) = @_;
  
      $config or return [];
  
      my @flags = map +( join '=', $_, $config->{$_} ), keys %{$config};
  
      $self->_expand_flags_inplace( \@flags, $expand_env );
  
      return \@flags;
  }
  
  sub _expand_flags_inplace {
      my ( $self, $flags, $env ) = @_;
  
      for my $flag ( @{$flags} ) {
          for my $key ( keys %{$env} ) {
              my $placeholder = '%' . uc($key) . '%';
              $flag =~ s/$placeholder/$env->{$key}/gsm;
          }
      }
  
      return;
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
PAKKET_BUILDER

$fatpacked{"Pakket/Builder/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER_NATIVE';
  package Pakket::Builder::Native;
  # ABSTRACT: Build Native Pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use Log::Any qw< $log >;
  use Pakket::Log;
  use Pakket::Builder::Native::Makefile;
  
  with qw<Pakket::Role::Builder>;
  
  sub build_package {
      my ( $self, $package, $build_dir, $prefix, $flags ) = @_;
  
      if (   $build_dir->child('configure')->exists
          || $build_dir->child('config')->exists )
      {
          my $builder = Pakket::Builder::Native::Makefile->new();
          $builder->build_package( $package, $build_dir, $prefix, $flags );
      } else {
          die $log->critical(
              "I cannot build this native package. No 'configure'.");
      }
  
      return;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_BUILDER_NATIVE

$fatpacked{"Pakket/Builder/Native/Makefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER_NATIVE_MAKEFILE';
  package Pakket::Builder::Native::Makefile;
  # ABSTRACT: Build Native Pakket packages that use Makefile
  
  use Moose;
  use MooseX::StrictConstructor;
  use Log::Any   qw< $log >;
  use Path::Tiny qw< path >;
  use Pakket::Log;
  use Pakket::Utils qw< generate_env_vars >;
  
  with qw<Pakket::Role::Builder>;
  
  sub build_package {
      my ( $self, $package, $build_dir, $prefix, $flags ) = @_;
  
      $log->info("Building Native library: $package");
  
      my $opts = {
          'env' => {
              generate_env_vars($build_dir, $prefix),
          },
      };
  
      my $configurator;
      if ( -f $build_dir->child('configure') ) {
          $configurator = './configure';
      } elsif ( -f $build_dir->child('config') ) {
          $configurator = './config';
      } elsif ( -f $build_dir->child('Configure') ) {
          $configurator = './Configure';
      } else {
          die $log->critical( "Don't know how to configure $package"
                  . " (Cannot find executale 'configure' or 'config')" );
      }
  
      my @seq = (
  
          # configure
          [
              $build_dir,
              [
                  $configurator, '--prefix=' . $prefix->absolute,
                  @{$flags},
              ],
              $opts,
          ],
  
          # build
          [ $build_dir, ['make'], $opts, ],
  
          # install
          [ $build_dir, [ 'make', 'install' ], $opts, ],
      );
  
      my $success = $self->run_command_sequence(@seq);
  
      if ( !$success ) {
          die $log->critical("Failed to build $package");
      }
  
      $log->info("Done preparing $package");
  
      return;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_BUILDER_NATIVE_MAKEFILE

$fatpacked{"Pakket/Builder/NodeJS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER_NODEJS';
  package Pakket::Builder::NodeJS;
  # ABSTRACT: Build Perl Pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use English    qw< -no_match_vars >;
  use Log::Any   qw< $log >;
  use Path::Tiny qw< path >;
  use Pakket::Log;
  use Pakket::Utils qw< generate_env_vars >;
  
  with qw<Pakket::Role::Builder>;
  
  sub build_package {
      my ( $self, $package, $build_dir, $prefix ) = @_;
  
      $log->info("Building NodeJS module: $package");
  
      my $opts = {
          'env' => {
              generate_env_vars($prefix),
          },
      };
  
      my $original_dir = Path::Tiny->cwd;
      my $install_base = $prefix->absolute;
  
      my $source = $build_dir;
  
      if ( $ENV{'NODE_NPM_REGISTRY'} ) {
          $self->run_command( $build_dir,
              [ qw< npm set registry >, $ENV{'NODE_NPM_REGISTRY'} ], $opts );
          $source = $package;
      }
  
      my $success
          = $self->run_command( $build_dir, [ qw< npm install -g >, $source ],
          $opts );
  
      if ( !$success ) {
          die $log->critical("Failed to build $package");
      }
  
      $log->info("Done preparing $package");
  
      return;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_BUILDER_NODEJS

$fatpacked{"Pakket/Builder/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER_PERL';
  package Pakket::Builder::Perl;
  # ABSTRACT: Build Perl Pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use English    qw< -no_match_vars >;
  use Log::Any   qw< $log >;
  use Pakket::Log;
  use Pakket::Utils qw< generate_env_vars >;
  use Carp ();
  
  with qw<Pakket::Role::Builder>;
  
  sub build_package {
      my ( $self, $package, $build_dir, $prefix, $flags ) = @_;
  
      $log->info("Building Perl module: $package");
  
      my %env  = generate_env_vars( $build_dir, $prefix );
      my $opts = { 'env' => \%env };
  
      foreach my $env_var ( keys %env ) {
          $log->trace( 'export ' . join '=', $env_var, $env{$env_var} );
      }
  
      my $install_base = $prefix->absolute;
  
      # taken from cpanminus
      my %should_use_mm = map +( "perl/$_" => 1 ),
          qw( version ExtUtils-ParseXS ExtUtils-Install ExtUtils-Manifest );
  
      my @seq;
      if ( $build_dir->child('Build.PL')->exists
          && !exists $should_use_mm{$package} )
      {
          @seq = (
  
              # configure
              [
                  $build_dir,
                  [ 'perl', '-f', 'Build.PL', '--install_base', $install_base, @{$flags} ],
                  $opts,
              ],
  
              # build
              [ $build_dir, ['perl', '-f', './Build'], $opts ],
  
              # install
              [ $build_dir, [ 'perl', '-f', './Build', 'install' ], $opts ],
          );
      } elsif ( $build_dir->child('Makefile.PL')->exists ) {
          @seq = (
  
              # configure
              [
                  $build_dir,
                  [ 'perl', '-f', 'Makefile.PL', "INSTALL_BASE=$install_base", @{$flags} ],
                  $opts,
              ],
  
              # build
              [ $build_dir, ['make'], $opts ],
  
              # install
              [ $build_dir, [ 'make', 'install' ], $opts ],
          );
      } else {
          Carp::croak('Could not find an installer (Makefile.PL/Build.PL)');
      }
  
      my $success = $self->run_command_sequence(@seq);
  
      if ( !$success ) {
          die $log->critical("Failed to build $package");
      }
  
      $log->info("Done preparing $package");
  
      return;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_BUILDER_PERL

$fatpacked{"Pakket/Bundler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUNDLER';
  package Pakket::Bundler;
  # ABSTRACT: Bundle pakket packages into a parcel file
  
  use Moose;
  use MooseX::StrictConstructor;
  use JSON::MaybeXS;
  use File::Spec;
  use Path::Tiny        qw< path >;
  use Types::Path::Tiny qw< AbsPath >;
  use Log::Any          qw< $log >;
  
  use Pakket::Package;
  use Pakket::Repository::Parcel;
  
  use Pakket::Constants qw<
      PARCEL_FILES_DIR
      PARCEL_METADATA_FILE
  >;
  
  use Pakket::Utils qw< encode_json_pretty >;
  
  use constant {
      'BUNDLE_DIR_TEMPLATE' => 'BUNDLE-XXXXXX',
  };
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasParcelRepo
  >;
  
  has 'files_manifest' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { return +{} },
  );
  
  # TODO
  # The reason behind this is to make sure we already inflate
  # the Parcel Repo before using it, because we might chdir
  # when we want to use it, and if the directory paths are
  # relative, it might not match anymore. This is why it was
  # AbsPath prior. We can try it and if it works remove this
  # chunk. -- SX.
  sub BUILD {
      my $self = shift;
      $self->parcel_repo;
  }
  
  sub bundle {
      my ( $self, $build_dir, $package, $files ) = @_;
  
      my $original_dir = Path::Tiny->cwd;
  
      # totally arbitrary, maybe add to constants?
      my $parcel_dir_path = Path::Tiny->tempdir(
          'TEMPLATE' => BUNDLE_DIR_TEMPLATE(),
          'CLEANUP'  => 1,
      );
  
      $parcel_dir_path->child( PARCEL_FILES_DIR() )->mkpath;
  
      chdir $parcel_dir_path->child( PARCEL_FILES_DIR() )->stringify;
  
      foreach my $orig_file ( keys %{$files} ) {
          $log->debug("Bundling $orig_file");
          my $new_fullname = $self->_rebase_build_to_output_dir(
              $build_dir, $orig_file,
          );
  
          -e $new_fullname
              and die 'Odd. File already seems to exist in packaging dir. '
                    . "Stopping.\n";
  
          # create directories
          $new_fullname->parent->mkpath;
  
          # regular file
          if ( $files->{$orig_file} eq '' ) {
              path($orig_file)->copy($new_fullname)
                  or die "Failed to copy $orig_file to $new_fullname\n";
  
              my $raw_mode = ( stat($orig_file) )[2];
              my $mode_str = sprintf '%04o', $raw_mode & oct('07777');
              chmod oct($mode_str), $new_fullname;
          } else {
              my $new_symlink = $self->_rebase_build_to_output_dir(
                  $build_dir, $files->{$orig_file},
              );
  
              my $previous_dir = Path::Tiny->cwd;
              chdir $new_fullname->parent;
              symlink $new_symlink, $new_fullname->basename;
              chdir $previous_dir;
          }
      }
  
      path( PARCEL_METADATA_FILE() )->spew_utf8(
          encode_json_pretty( $package->spec ),
      );
  
      chdir '..';
  
      $log->infof( 'Creating parcel file for %s', $package->full_name );
  
      # The lovely thing here is that is creates a parcel file from the
      # bundled directory, which gets cleaned up automatically
      $self->parcel_repo->store_package_parcel(
          $package,
          $parcel_dir_path,
      );
  
      chdir $original_dir;
  
      return;
  }
  
  sub _rebase_build_to_output_dir {
      my ( $self, $build_dir, $orig_filename ) = @_;
      ( my $new_filename = $orig_filename ) =~ s/^$build_dir//ms;
      my @parts = File::Spec->splitdir($new_filename);
  
      # in case the path is absolute (leading slash)
      # the split function will generate an empty first element
      # if it's relative, it will have value and shouldn't be removed
      $parts[0] eq '' and shift @parts;
  
      return path(@parts);
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
PAKKET_BUNDLER

$fatpacked{"Pakket/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI';
  package Pakket::CLI;
  # ABSTRACT: Command line interface for Pakket
  
  use strict;
  use warnings;
  use App::Cmd::Setup '-app';
  
  1;
PAKKET_CLI

$fatpacked{"Pakket/CLI/Command/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_BUILD';
  package Pakket::CLI::Command::build;
  # ABSTRACT: Build a Pakket package
  
  use strict;
  use warnings;
  
  use Pakket::CLI '-command';
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC PAKKET_LATEST_VERSION >;
  use Pakket::Config;
  use Pakket::Builder;
  use Pakket::Requirement;
  use Pakket::Log;
  use Pakket::Utils::Repository qw< gen_repo_config >;
  
  use Path::Tiny qw< path >;
  use Log::Any   qw< $log >;
  use Log::Any::Adapter;
  
  sub abstract    { 'Build a package' }
  sub description { 'Build a package' }
  
  sub opt_spec {
      return (
          [ 'input-file=s',   'build stuff from this file' ],
          [ 'build-dir=s',    'use an existing build directory' ],
          [ 'keep-build-dir', 'do not delete the build directory' ],
          [ 'spec-dir=s',     'directory holding the specs' ],
          [ 'source-dir=s',   'directory holding the sources' ],
          [ 'output-dir=s',   'output directory (default: .)' ],
          [ 'config|c=s',     'configuration file' ],
          [ 'verbose|v+',     'verbose output (can be provided multiple times)' ],
          [ 'log-file=s',     'Log file (default: build.log)' ],
      );
  }
  
  sub _determine_config {
      my ( $self, $opt ) = @_;
  
      my $config_file = $opt->{'config'};
      my $config_reader = Pakket::Config->new(
          $config_file ? ( 'files' => [$config_file] ) : (),
      );
  
      my $config = $config_reader->read_config;
  
      # Setup default repos
      my %repo_opt = (
          'spec'   => 'spec_dir',
          'source' => 'source_dir',
          'parcel' => 'output_dir',
      );
  
      foreach my $type ( keys %repo_opt ) {
          my $opt_key   = $repo_opt{$type};
          my $directory = $opt->{$opt_key};
          my $repo_conf = $self->gen_repo_config( $type, $directory );
          $repo_conf or $self->usage_error("Missing configuration for $type repository");
          $config->{'repositories'}{$type} = $repo_conf;
      }
  
      return $config;
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      $opt->{'config'} = $self->_determine_config($opt);
      $opt->{'config'}{'env'}{'cli'} = 1;
  
      my $log_file = $opt->{'log_file'} || $opt->{'config'}{'log_file'};
      Log::Any::Adapter->set(
          'Dispatch',
          'dispatcher' => Pakket::Log->build_logger(
              $opt->{'verbose'}, $log_file,
          ),
      );
  
      my @specs;
      if ( defined ( my $file = $opt->{'input_file'} ) ) {
          my $path = path($file);
          $path->exists && $path->is_file
              or $self->usage_error("Bad input file: $path");
  
          push @specs, $path->lines_utf8( { 'chomp' => 1 } );
      } elsif ( @{$args} ) {
          @specs = @{$args};
      } else {
          $self->usage_error('Must specify at least one package or a file');
      }
  
      foreach my $spec_str (@specs) {
          my ( $cat, $name, $version, $release ) =
              $spec_str =~ PAKKET_PACKAGE_SPEC();
  
          if ( ! ( $cat && $name && $version && $release ) ) {
              $self->usage_error(
                  "Provide category/name=version:release, not '$spec_str'",
              );
          }
  
          my $req;
          eval { $req = Pakket::Requirement->new_from_string($spec_str); 1; }
          or do {
              my $error = $@ || 'Zombie';
              $log->debug("Failed to create Pakket::Requirement: $error");
              $self->usage_error(
                  "We do not understand this package string: $spec_str",
              );
          };
  
          push @{ $opt->{'prereqs'} }, $req;
      }
  
      if ( $opt->{'build_dir'} ) {
          path( $opt->{'build_dir'} )->is_dir
              or die "You asked to use a build dir that does not exist.\n";
      }
  }
  
  sub execute {
      my ( $self, $opt ) = @_;
  
      my $builder = Pakket::Builder->new(
          'config' => $opt->{'config'},
  
          # Maybe we have it, maybe we don't
          map( +(
              defined $opt->{$_}
                  ? ( $_ => $opt->{$_} )
                  : ()
          ), qw< build_dir keep_build_dir > ),
      );
  
      $builder->build( @{ $opt->{'prereqs'} } );
  }
  
  1;
  
  __END__
PAKKET_CLI_COMMAND_BUILD

$fatpacked{"Pakket/CLI/Command/init.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_INIT';
  package Pakket::CLI::Command::init;
  
  # ABSTRACT: Initialize a pakket instance
  
  use strict;
  use warnings;
  use English '-no_match_vars';
  use Pakket::CLI '-command';
  use Pakket::Log;
  use Pakket::Utils qw< is_writeable >;
  use Log::Any::Adapter;
  use Log::Any   qw< $log >;
  use Path::Tiny qw< path >;
  use File::HomeDir;
  
  sub abstract    {'Initialize Pakket'}
  sub description {'Initialize Pakket'}
  
  sub opt_spec {
      return (
          [ 'repo-dir=s', 'repo directory (default: /var/lib/pakket)' ],
          [ 'local',      'short-hand for --repo-dir=~/.pakket' ],
          [ 'force|f',    'force init (for reinitialization)' ],
          [ 'verbose|v+', 'verbose output (can be provided multiple times)' ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      my $logger = Pakket::Log->cli_logger(2); # verbosity
      Log::Any::Adapter->set( 'Dispatch', dispatcher => $logger );
  
      # global installation and pakket is already available
      if (  !$opt->{'repo_dir'}
          && $ENV{'PAKKET_REPO'}
          && -d $ENV{'PAKKET_REPO'}
          && !$opt->{'force'} )
      {
          die $log->critical(
              "Pakket is already globally initialized at $ENV{'PAKKET_REPO'}");
      }
  
      $self->{'repo'} = path(
          $opt->{'repo_dir'} // $opt->{'local'}
          ? ( File::HomeDir->my_home, '.pakket' )
          : ( Path::Tiny->rootdir, qw< usr local pakket > ),
      );
  }
  
  sub execute {
      my $self = shift;
  
      # 1. create main repo directory
      # TODO: allow configuration files? interactive?
      my $repo_dir = $self->{'repo'};
  
      if ( !is_writeable($repo_dir) ) {
          die $log->critical("No permissions to write to $repo_dir.");
      }
  
      $repo_dir->is_dir
          or $repo_dir->mkpath;
  
      # 2. print the configuration
      my $pakket_homedir
          = path( File::HomeDir->my_home,
          $OSNAME =~ m{win}ms ? 'pakket' : '.pakket' );
  
      $pakket_homedir->is_dir
          or $pakket_homedir->mkpath;
  
      # FIXME: currently only bash support, what about csh/fish/zsh/Windows?
      my $shellfile = path( $pakket_homedir, 'pakket.sh' );
      $shellfile->spew(
          "export PAKKET_REPO=$repo_dir\n",
          "export PERL5LIB=$repo_dir/lib/perl5:\$PERL5LIB\n",
          "export LD_LIBRARY_PATH=$repo_dir/lib:\$LD_LIBRARY_PATH\n",
      );
  
      $log->info("Done. Please add $shellfile to your bashrc.");
  }
  
  1;
  
  __END__
PAKKET_CLI_COMMAND_INIT

$fatpacked{"Pakket/CLI/Command/install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_INSTALL';
  package Pakket::CLI::Command::install;
  # ABSTRACT: The pakket install command
  
  use strict;
  use warnings;
  use Pakket::CLI '-command';
  use Pakket::Installer;
  use Pakket::Config;
  use Pakket::Log;
  use Pakket::Package;
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC >;
  use Log::Any::Adapter;
  use Path::Tiny      qw< path >;
  
  sub abstract    { 'Install a package' }
  sub description { 'Install a package' }
  
  sub _determine_config {
      my ( $self, $opt ) = @_;
  
      # Read configuration
      my $config_file   = $opt->{'config'};
      my $config_reader = Pakket::Config->new(
          $config_file ? ( 'files' => [$config_file] ) : (),
      );
  
      my $config = $config_reader->read_config;
  
      # Default File backend
      if ( $opt->{'from'} ) {
          $config->{'repositories'}{'parcel'} = [
              'File', 'directory' => $opt->{'from'},
          ];
      }
  
      # Double check
      if ( !$config->{'repositories'}{'parcel'} ) {
          $self->usage_error(
              "Missing where to install\n"
            . '(Create a configuration or use --from)',
          );
      }
  
      return $config;
  }
  
  sub _determine_packages {
      my ( $self, $opt, $args ) = @_;
  
      my @package_strs
          = defined $opt->{'input_file'}
          ? path( $opt->{'input_file'} )->lines_utf8( { 'chomp' => 1 } )
          : @{$args};
  
      my @packages;
      foreach my $package_str (@package_strs) {
          my ( $pkg_cat, $pkg_name, $pkg_version, $pkg_release ) =
              $package_str =~ PAKKET_PACKAGE_SPEC();
  
          if ( !defined $pkg_version || !defined $pkg_release ) {
              $self->usage_error(
                  'Currently you must provide a version and release to install: '
                  .  $package_str,
              );
          }
  
          push @packages, Pakket::Package->new(
              'category' => $pkg_cat,
              'name'     => $pkg_name,
              'version'  => $pkg_version,
              'release'  => $pkg_release,
          );
      }
  
      return \@packages;
  }
  
  sub opt_spec {
      return (
          [
              'to=s',
              'directory to install the package in',
              { 'required' => 1 },
          ],
          [
              'from=s',
              'directory to install the packages from',
          ],
          [ 'input-file=s', 'install eveything listed in this file' ],
          [ 'config|c=s',   'configuration file' ],
          [
              'verbose|v+',
              'verbose output (can be provided multiple times)',
              { 'default' => 1 },
          ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      Log::Any::Adapter->set( 'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ) );
  
      $opt->{'pakket_dir'} = $opt->{'to'};
      $opt->{'config'}     = $self->_determine_config($opt);
      $opt->{'packages'}   = $self->_determine_packages( $opt, $args );
  
      $opt->{'config'}{'env'}{'cli'} = 1;
  }
  
  sub execute {
      my ( $self, $opt ) = @_;
  
      my $installer = Pakket::Installer->new(
          'config'     => $opt->{'config'},
          'pakket_dir' => $opt->{'pakket_dir'},
      );
  
      return $installer->install( @{ $opt->{'packages'} } );
  }
  
  1;
  
  __END__
PAKKET_CLI_COMMAND_INSTALL

$fatpacked{"Pakket/CLI/Command/manage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_MANAGE';
  package Pakket::CLI::Command::manage;
  # ABSTRACT: The pakket manage command
  
  use strict;
  use warnings;
  
  use Path::Tiny qw< path  >;
  use List::Util qw< first >;
  use Ref::Util  qw< is_arrayref >;
  use Log::Any   qw< $log >; # to log
  use Log::Any::Adapter;     # to set the logger
  
  use Pakket::CLI '-command';
  use Pakket::Log;
  use Pakket::Config;
  use Pakket::Manager;
  use Pakket::Constants qw< PAKKET_VALID_PHASES >;
  use Pakket::Utils::Repository qw< gen_repo_config >;
  
  sub abstract    { 'Scaffold a project' }
  sub description { 'Scaffold a project' }
  
  sub opt_spec {
      return (
          [ 'cpanfile=s',   'cpanfile to configure from' ],
          [ 'spec-dir=s',   'directory to write the spec to (JSON files)' ],
          [ 'source-dir=s', 'directory to write the sources to (downloads if provided)' ],
          [ 'parcel-dir=s', 'directory where build output (parcels) are' ],
          [ 'cache-dir=s',  'directory to get sources from (optional)' ],
          [ 'additional-phase=s@',
            "additional phases to use ('develop' = author_requires, 'test' = test_requires). configure & runtime are done by default.",
          ],
          [ 'config|c=s',   'configuration file' ],
          [ 'verbose|v+',   'verbose output (can be provided multiple times)' ],
          [ 'add=s%',       '(deps) add the following dependency (phase=category/name=version[:release])' ],
          [ 'remove=s%',    '(deps) add the following dependency (phase=category/name=version[:release])' ],
          [ 'cpan-02packages=s', '02packages file (optional)' ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      Log::Any::Adapter->set(
          'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ),
      );
  
      $self->{'opt'}  = $opt;
      $self->{'args'} = $args;
  
      $self->_validate_arg_command;
      $self->_validate_arg_cache_dir;
      $self->_read_config;
  }
  
  sub execute {
      my $self = shift;
      my $package;
  
      my $command = $self->{'command'};
  
      my $category =
          $self->{'spec'}     ? $self->{'spec'}->category :
          $self->{'cpanfile'} ? 'perl' :
          undef;
  
      if ( $command =~ /^(?:add|remove|deps|show)$/ and !$self->{'cpanfile'} ) {
          $package = Pakket::Package->new(
              'category' => $category,
              'name'     => $self->{'spec'}->name,
              'version'  => $self->{'spec'}->version,
              'release'  => $self->{'spec'}->release,
          );
      }
  
      my $manager = Pakket::Manager->new(
          config          => $self->{'config'},
          cpanfile        => $self->{'cpanfile'},
          cache_dir       => $self->{'cache_dir'},
          phases          => $self->{'gen_phases'},
          package         => $package,
          file_02packages => $self->{'file_02packages'},
      );
  
      if ( $command eq 'add' ) {
          $manager->add_package;
  
      } elsif ( $command eq 'remove' ) {
          # TODO: check we are allowed to remove package (dependencies)
          $manager->remove_package_spec;
          $manager->remove_package_source;
  
      } elsif ( $command eq 'deps' ) {
          $self->{'opt'}{'add'}    and $manager->add_dependency( $self->{'dependency'} );
          $self->{'opt'}{'remove'} and $manager->remove_dependency( $self->{'dependency'} );
  
      } elsif ( $command eq 'list' ) {
          $manager->list_ids( $self->{'list_type'} );
  
      } elsif ( $command eq 'show' ) {
          $manager->show_package_config;
      }
  }
  
  sub _read_config {
      my $self = shift;
  
      my $config_file   = $self->{'opt'}{'config'};
      my $config_reader = Pakket::Config->new(
          $config_file ? ( 'files' => [$config_file] ) : (),
      );
  
      $self->{'config'} = $config_reader->read_config;
  
      $self->_validate_repos;
  }
  
  sub _validate_repos {
      my $self = shift;
  
      my %cmd2repo = (
          'add'    => [ 'spec', 'source' ],
          'remove' => [ 'spec', 'source' ],
          'deps'   => [ 'spec' ],
          'show'   => [ 'spec' ],
          'list'   => {
              spec   => [ 'spec'   ],
              parcel => [ 'parcel' ],
              source => [ 'source' ],
          },
      );
  
      my $config  = $self->{'config'};
      my $command = $self->{'command'};
  
      my @required_repos = @{
          $command eq 'list'
              ? $cmd2repo{$command}{ $self->{'list_type'} }
              : $cmd2repo{$command}
      };
  
      my %repo_opt = (
          'spec'   => 'spec_dir',
          'source' => 'source_dir',
          'parcel' => 'parcel_dir',
      );
  
      for my $type ( @required_repos ) {
          my $opt_key   = $repo_opt{$type};
          my $directory = $self->{'opt'}{$opt_key};
          my $repo_conf = $self->gen_repo_config( $type, $directory );
          $repo_conf or $self->usage_error("Missing configuration for $type repository");
          $config->{'repositories'}{$type} = $repo_conf;
      }
  }
  
  sub _validate_arg_command {
      my $self = shift;
  
      my $command = shift @{ $self->{'args'} }
          or $self->usage_error("Must pick action (add/remove/deps/list/show)");
  
      grep { $command eq $_ } qw< add remove deps list show >
          or $self->usage_error( "Wrong command (add/remove/deps/list/show)" );
  
      $self->{'command'} = $command;
  
      $command eq 'add'    and $self->_validate_args_add;
      $command eq 'remove' and $self->_validate_args_remove;
      $command eq 'deps'   and $self->_validate_args_dependency;
      $command eq 'list'   and $self->_validate_args_list;
      $command eq 'show'   and $self->_validate_args_show;
  }
  
  sub _validate_arg_cache_dir {
      my $self = shift;
  
      my $cache_dir = $self->{'opt'}{'cache_dir'};
  
      if ( $cache_dir ) {
          path( $cache_dir )->exists
              or $self->usage_error( "cache-dir: $cache_dir doesn't exist\n" );
          $self->{'cache_dir'} = $cache_dir;
      }
  }
  
  sub _validate_args_add {
      my $self = shift;
  
      my $cpanfile = $self->{'opt'}{'cpanfile'};
      my $additional_phase = $self->{'opt'}{'additional_phase'};
  
      $self->{'file_02packages'} = $self->{'opt'}{'cpan_02packages'};
  
      if ( $cpanfile ) {
          @{ $self->{'args'} }
              and $self->usage_error( "You can't have both a 'spec' and a 'cpanfile'\n" );
          $self->{'cpanfile'} = $cpanfile;
      } else {
          $self->_read_set_spec_str;
      }
  
      # TODO: config ???
      $self->{'gen_phases'} = [qw< configure runtime >];
      if ( is_arrayref($additional_phase) ) {
          exists PAKKET_VALID_PHASES->{$_} or $self->usage_error( "Unsupported phase: $_" )
              for @{ $additional_phase };
          push @{ $self->{'gen_phases'} } => @{ $additional_phase };
      }
  }
  
  sub _validate_args_remove {
      my $self = shift;
      $self->_read_set_spec_str;
  }
  
  sub _validate_args_dependency {
      my $self = shift;
      my $opt  = $self->{'opt'};
  
      # spec
      $self->_read_set_spec_str;
  
      # dependency
      my $action = $opt->{'add'} || $opt->{'remove'};
      $action or $self->usage_error( "Missing arg: add/remove (mandatory for 'deps')" );
  
      my ( $phase, $dep_str ) = %{ $action };
      $phase or $self->usage_error( "Invalid dependency: missing phase" );
  
      my $dep = $self->_read_spec_str($dep_str);
      defined $dep->{'version'}
          or $self->usage_error( "Invalid dependency: missing version" );
      $dep->{'phase'} = $phase;
  
      $self->{'dependency'}  = $dep;
  }
  
  sub _validate_args_list {
      my $self = shift;
  
      my $type = shift @{ $self->{'args'} };
  
      $type and grep { $type eq $_ or $type eq $_.'s' } qw< parcel spec source >
          or $self->usage_error( "Invalid type of list (parcels/specs/sources): " . ($type||"") );
  
      $self->{'list_type'} = $type =~ s/s?$//r;
  }
  
  sub _validate_args_show {
      my $self = shift;
      $self->_read_set_spec_str;
  }
  
  sub _read_spec_str {
      my ( $self, $spec_str ) = @_;
  
      my $spec = Pakket::Requirement->new_from_string($spec_str);
  
      first { $_ eq $spec->category } qw< perl native > # add supported categories
          or $self->usage_error( "Wrong 'name' format\n" );
  
      return $spec;
  }
  
  sub _read_set_spec_str {
      my $self = shift;
  
      my $spec_str = shift @{ $self->{'args'} };
      $spec_str or $self->usage_error( "Must provide a package id (category/name=version:release)" );
  
      $self->{'spec'} = $self->_read_spec_str($spec_str);
  }
  
  1;
  __END__
PAKKET_CLI_COMMAND_MANAGE

$fatpacked{"Pakket/CLI/Command/run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_RUN';
  package Pakket::CLI::Command::run;
  # ABSTRACT: The pakket run command
  
  use strict;
  use warnings;
  use Pakket::CLI '-command';
  use Pakket::Runner;
  use Pakket::Log;
  use Log::Any::Adapter;
  use Path::Tiny qw< path >;
  
  sub abstract    { 'Run commands using pakket' }
  sub description { 'Run commands using pakket' }
  
  sub opt_spec {
      return (
          [
              'from=s',
              'defines pakket active directory to use. '
                  . '(mandatory, unless set in PAKKET_ACTIVE_PATH)',
          ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      Log::Any::Adapter->set( 'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ) );
  
      my $active_path
          = exists $ENV{'PAKKET_ACTIVE_PATH'}
          ? $ENV{'PAKKET_ACTIVE_PATH'}
          : $opt->{'from'};
  
      $active_path
          or $self->usage_error('No active path provided');
  
      $opt->{'active_path'} = $active_path;
  }
  
  sub execute {
      my ( $self, $opt, $args ) = @_;
  
      my $runner = Pakket::Runner->new(
          'active_path' => $opt->{'active_path'},
      );
  
      exit $runner->run( @{$args} );
  }
  
  1;
  
  __END__
PAKKET_CLI_COMMAND_RUN

$fatpacked{"Pakket/CLI/Command/serve.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_SERVE';
  package Pakket::CLI::Command::serve;
  # ABSTRACT: Serve Pakket objects over HTTP
  
  use strict;
  use warnings;
  
  use Path::Tiny      qw< path >;
  use Log::Any::Adapter;
  
  use Pakket::CLI '-command';
  use Pakket::Server;
  use Pakket::Log;
  
  sub abstract    { 'Serve objects' }
  sub description { 'Serve objects' }
  
  sub opt_spec {
      return (
          [ 'port=s',     'port where server will listen', ],
          [ 'verbose|v+', 'verbose output (can be provided multiple times)' ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt ) = @_;
  
      Log::Any::Adapter->set( 'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ) );
  }
  
  sub execute {
      my ( $self, $opt ) = @_;
      my $server = Pakket::Server->new(
          # default main object
          map( +(
              defined $opt->{$_}
                  ? ( $_ => $opt->{$_} )
                  : ()
          ), qw< port > ),
      );
  
      $server->run();
  }
  
  1;
  
  __END__
PAKKET_CLI_COMMAND_SERVE

$fatpacked{"Pakket/CLI/Command/uninstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_UNINSTALL';
  package Pakket::CLI::Command::uninstall;
  
  # ABSTRACT: The pakket uninstall command
  
  use strict;
  use warnings;
  
  use Log::Any qw< $log >;
  use Log::Any::Adapter;
  use CLI::Helpers qw<output prompt>;
  use Path::Tiny qw< path >;
  
  use Pakket::CLI '-command';
  use Pakket::Uninstaller;
  use Pakket::Log;
  use Pakket::Package;
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC >;
  
  sub abstract    {'Uninstall a package'}
  sub description {'Uninstall a package'}
  
  sub _determine_packages {
      my ( $self, $opt, $args ) = @_;
  
      my @package_strs
          = defined $opt->{'input_file'}
          ? path( $opt->{'input_file'} )->lines_utf8( { 'chomp' => 1 } )
          : @{$args};
  
      my @packages;
      foreach my $package_str (@package_strs) {
          my ( $pkg_cat, $pkg_name, $pkg_version, $pkg_release )
              = $package_str =~ PAKKET_PACKAGE_SPEC();
  
          if ( !$pkg_cat || !$pkg_name ) {
              die $log->critical(
                  "Can't parse $package_str. Use format category/package_name");
          }
  
          push @packages, { 'category' => $pkg_cat, 'name' => $pkg_name };
      }
  
      return \@packages;
  }
  
  sub _validate_arg_lib_dir {
      my ( $self, $opt ) = @_;
  
      my $lib_dir = $opt->{'lib_dir'};
  
      $lib_dir
          or $self->usage_error(
          "please define the library dir --lib-dir <path_to_library>\n");
  
      path($lib_dir)->exists
          or $self->usage_error("Library dir: $lib_dir doesn't exist\n");
  
      $self->{'lib_dir'} = $lib_dir;
  }
  
  sub opt_spec {
      return (
          [ 'lib-dir=s',            'repo directory' ],
          [ 'input-file=s',         'uninstall eveything listed in this file' ],
          [ 'without-dependencies', 'don\'t remove dependencies' ],
          [
              'verbose|v+',
              'verbose output (can be provided multiple times)',
              { 'default' => 1 },
          ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      Log::Any::Adapter->set( 'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ) );
  
      $self->_validate_arg_lib_dir($opt);
      $opt->{'packages'} = $self->_determine_packages( $opt, $args );
  }
  
  sub execute {
      my ( $self, $opt ) = @_;
  
      my $uninstaller = Pakket::Uninstaller->new(
          'lib_dir'              => $self->{'lib_dir'},
          'packages'             => $opt->{'packages'},
          'without_dependencies' => $opt->{'without_dependencies'},
      );
  
      my @packages_for_uninstall
          = $uninstaller->get_list_of_packages_for_uninstall();
  
      output("We are going to remove:");
      for my $package (@packages_for_uninstall) {
          output("$package->{category}/$package->{name}");
      }
  
      prompt( "Continue?", yn => 1 ) or return;
  
      $uninstaller->uninstall();
  
      return;
  }
  
  1;
  
  __END__
PAKKET_CLI_COMMAND_UNINSTALL

$fatpacked{"Pakket/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CONFIG';
  package Pakket::Config;
  # ABSTRACT: Read and represent Pakket configurations
  
  use Moose;
  use MooseX::StrictConstructor;
  use Config::Any;
  use Path::Tiny        qw< path >;
  use Types::Path::Tiny qw< Path >;
  use Log::Any          qw< $log >;
  use Carp              qw< croak >;
  
  has 'paths' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'default' => sub { return ['~/.pakket', '/etc/pakket'] },
  );
  
  has 'extensions' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'default' => sub { return [qw< json yaml yml conf cfg >] },
  );
  
  has 'files' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          if ( $ENV{'PAKKET_CONFIG_FILE'} ) {
              return [ $ENV{'PAKKET_CONFIG_FILE'} ];
          }
  
          my %files;
          foreach my $path ( @{ $self->{'paths'} } ) {
              foreach my $extension ( @{ $self->{'extensions'} } ) {
                  my $file = path("$path.$extension");
  
                  $file->exists
                      or next;
  
                  $files{$path}
                      and croak $log->criticalf(
                      'Multiple extensions for same config file name: %s and %s',
                      $files{$path}, $file
                      );
  
                  $files{$path} = $file;
              }
  
              # We found a file in order of precedence
              # so we return it
              $files{$path}
                  and return [ $files{$path} ];
          }
  
          # Could not find any files
          return [];
      },
  );
  
  sub read_config {
      my $self   = shift;
  
      @{ $self->files }
          or return {};
  
      my $config = Config::Any->load_files({
          'files'   => $self->files,
          'use_ext' => 1,
      });
  
      my %cfg;
      foreach my $config_chunk ( @{$config} ) {
          foreach my $filename ( keys %{$config_chunk} ) {
              my %config_part = %{ $config_chunk->{$filename} };
              @cfg{ keys(%config_part) } = values %config_part;
              $log->info("Using config file $filename");
          }
      }
  
      return \%cfg;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_CONFIG

$fatpacked{"Pakket/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CONSTANTS';
  package Pakket::Constants; ## no critic (Subroutines::ProhibitExportingUndeclaredSubs)
  # ABSTRACT: Constants used in Pakket
  
  use strict;
  use warnings;
  use parent 'Exporter';
  
  use constant {
      'PARCEL_EXTENSION'     => 'pkt',
      'PARCEL_FILES_DIR'     => 'files',
      'PARCEL_METADATA_FILE' => 'meta.json',
  
      # CATEGORY/PACKAGE                 == latest version, latest release
      # CATEGORY/PACKAGE=VERSION         == Exact version, latest release
      # CATEGORY/PACKAGE=VERSION:RELEASE == Exact version and release
      'PAKKET_PACKAGE_SPEC'  => qr{
          ^
          ( [^/]+ )       # category
          /
          ( [^=]+ )       # name
          (?:
              =
              ( [^:]+ )   # optional version
              (?:
                  :
                  (.*)    # optional release
              )?
          )?
          $
      }xms,
  
      'PAKKET_LATEST_VERSION'  => 'LATEST',
      'PAKKET_DEFAULT_RELEASE' => 1,
  
      'PAKKET_INFO_FILE'       => 'info.json',
  
      'PAKKET_VALID_PHASES'    => {
          'configure' => 1,
          'develop'   => 1,
          'runtime'   => 1,
          'test'      => 1,
      },
  };
  
  our @EXPORT_OK = qw<
      PARCEL_EXTENSION
      PARCEL_FILES_DIR
      PARCEL_METADATA_FILE
      PAKKET_PACKAGE_SPEC
      PAKKET_LATEST_VERSION
      PAKKET_DEFAULT_RELEASE
      PAKKET_INFO_FILE
      PAKKET_VALID_PHASES
  >;
  
  1;
PAKKET_CONSTANTS

$fatpacked{"Pakket/InfoFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_INFOFILE';
  package Pakket::InfoFile;
  
  # ABSTRACT: Functions to work with 'info.json'
  
  use Log::Any qw< $log >;
  use JSON::MaybeXS qw< decode_json >;
  use Pakket::Utils qw< encode_json_pretty >;
  use Pakket::Constants qw<PAKKET_INFO_FILE>;
  
  sub add_package {
      my ( $parcel_dir, $dir, $package, $opts ) = @_;
  
      my $prereqs      = $package->prereqs;
      my $install_data = load_info_file($dir);
  
      my %files;
  
      # get list of files
      $parcel_dir->visit(
          sub {
              my ( $path, $state ) = @_;
  
              $path->is_file
                  or return;
  
              my $filename = $path->relative($parcel_dir);
              $files{$filename} = {
                  'category' => $package->category,
                  'name'     => $package->name,
                  'version'  => $package->version,
                  'release'  => $package->release,
              };
          },
          { 'recurse' => 1 },
      );
  
      my ( $cat, $name ) = ( $package->category, $package->name );
      $install_data->{'installed_packages'}{$cat}{$name} = {
          'version'   => $package->version,
          'release'   => $package->release,
          'files'     => [ keys %files ],
          'as_prereq' => $opts->{'as_prereq'} ? 1 : 0,
          'prereqs'   => $package->prereqs,
      };
  
      foreach my $file ( keys %files ) {
          $install_data->{'installed_files'}{$file} = $files{$file};
      }
  
      save_info_file( $dir, $install_data );
  }
  
  sub load_info_file {
      my $dir = shift;
  
      my $info_file = $dir->child( PAKKET_INFO_FILE() );
  
      my $install_data
          = $info_file->exists
          ? decode_json( $info_file->slurp_utf8 )
          : {};
  
      return $install_data;
  }
  
  sub save_info_file {
      my ( $dir, $install_data ) = @_;
  
      my $info_file = $dir->child( PAKKET_INFO_FILE() );
  
      $info_file->spew_utf8( encode_json_pretty($install_data) );
  }
  
  1;
  
  __END__
PAKKET_INFOFILE

$fatpacked{"Pakket/Installer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_INSTALLER';
  package Pakket::Installer;
  # ABSTRACT: Install pakket packages into an installation directory
  
  use Moose;
  use MooseX::StrictConstructor;
  use Path::Tiny            qw< path  >;
  use Types::Path::Tiny     qw< Path  >;
  use File::Copy::Recursive qw< dircopy >;
  use Time::HiRes           qw< time >;
  use Log::Any              qw< $log >;
  use JSON::MaybeXS         qw< decode_json >;
  use Archive::Any;
  use English               qw< -no_match_vars >;
  
  use Pakket::Repository::Parcel;
  use Pakket::Requirement;
  use Pakket::Package;
  use Pakket::InfoFile;
  use Pakket::LibDir;
  use Pakket::Log       qw< log_success log_fail >;
  use Pakket::Types     qw< PakketRepositoryBackend >;
  use Pakket::Utils     qw< is_writeable >;
  use Pakket::Constants qw<
      PARCEL_METADATA_FILE
      PARCEL_FILES_DIR
  >;
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasParcelRepo
      Pakket::Role::RunCommand
  >;
  
  has 'pakket_dir' => (
      'is'       => 'ro',
      'isa'      => Path,
      'coerce'   => 1,
      'required' => 1,
  );
  
  sub install {
      my ( $self, @packages ) = @_;
  
      if ( !@packages ) {
          $log->notice('Did not receive any parcels to deliver');
          return;
      }
  
      my $work_dir = Pakket::LibDir::create_new_work_dir($self->pakket_dir);
  
      my $installer_cache = {};
      foreach my $package (@packages) {
          $self->install_package( $package, $work_dir, { 'cache' => $installer_cache } );
      }
  
      Pakket::LibDir::activate_work_dir($work_dir);
  
      $log->infof(
          "Finished installing %d packages into $self->pakket_dir",
          scalar keys %{$installer_cache},
      );
  
      log_success( 'Finished installing: ' . join ', ',
          map $_->full_name, @packages );
  
      Pakket::LibDir::remove_old_libraries($self->pakket_dir);
  
      return;
  }
  
  sub try_to_install_package {
      my ( $self, $package, $dir, $opts ) = @_;
  
      $log->debugf( 'Trying to install %s', $package->full_name );
  
      # First we check whether a package exists, because if not
      # we wil throw a silly critical warning about it
      # This can also speed stuff up, but maybe should be put into
      # "has_package" wrapper function... -- SX
      $self->parcel_repo->has_object( $package->id )
          or return;
  
      eval {
          $self->install_package( $package, $dir, $opts );
          1;
      } or do {
          $log->debugf( 'Could not install %s', $package->full_name );
          return;
      };
  
      return 1;
  }
  
  sub install_package {
      my ( $self, $package, $dir, $opts ) = @_;
      my $installer_cache = $opts->{'cache'};
  
      # Are we in a regular (non-bootstrap) mode?
      # Are we using a bootstrap version of a package?
      if ( ! $opts->{'skip_prereqs'} && $package->is_bootstrap ) {
          die $log->critical(
              'You are trying to install a bootstrap version of %s.'
            . ' Please rebuild this package from scratch.',
              $package->full_name,
          );
      }
  
      # Extracted to use more easily in the install cache below
      my $pkg_cat  = $package->category;
      my $pkg_name = $package->name;
  
      $log->debugf( "About to install %s (into $dir)", $package->full_name );
  
      if ( defined $installer_cache->{$pkg_cat}{$pkg_name} ) {
          my $ver_rel = $installer_cache->{$pkg_cat}{$pkg_name};
          my ( $version, $release ) = @{$ver_rel};
  
          # Check version
          if ( $version ne $package->version ) {
              die $log->criticalf(
                  "%s=$version already installed. "
                . "Cannot install new version: %s",
                $package->short_name,
                $package->version,
              );
          }
  
          # Check release
          if ( $release ne $package->release ) {
              die $log->criticalf(
                  '%s=%s:%s already installed. '
                . 'Cannot install new version: %s:%s',
                  $package->short_name,
                  $version, $release,
                  $package->release,
              );
          }
  
          $log->debugf( '%s already installed.', $package->full_name );
  
          return;
      } else {
          $installer_cache->{$pkg_cat}{$pkg_name} = [
              $package->version, $package->release,
          ];
      }
  
      if ( !is_writeable($dir) ) {
          die $log->critical(
              "Can't write to your installation directory ($dir)",
          );
      }
  
      my $parcel_dir
          = $self->parcel_repo->retrieve_package_parcel($package);
  
      my $full_parcel_dir = $parcel_dir->child( PARCEL_FILES_DIR() );
  
      # Get the spec and create a new Package object
      # This one will have the dependencies as well
      my $spec_file    = $full_parcel_dir->child( PARCEL_METADATA_FILE() );
      my $spec         = decode_json $spec_file->slurp_utf8;
      my $full_package = Pakket::Package->new_from_spec($spec);
  
      my $prereqs = $full_package->prereqs;
      foreach my $prereq_category ( keys %{$prereqs} ) {
          my $runtime_prereqs = $prereqs->{$prereq_category}{'runtime'};
  
          foreach my $prereq_name ( keys %{$runtime_prereqs} ) {
              my $prereq_data = $runtime_prereqs->{$prereq_name};
  
              # FIXME: This should be removed when we introduce version ranges
              # This forces us to install the latest version we have of
              # something, instead of finding the latest, based on the
              # version range, which "$prereq_version" contains. -- SX
              my $ver_rel = $self->parcel_repo->latest_version_release(
                  $prereq_category,
                  $prereq_name,
                  $prereq_data->{'version'},
              );
  
              my ( $prereq_version, $prereq_release ) = @{$ver_rel};
  
              my $prereq = Pakket::Requirement->new(
                  'category' => $prereq_category,
                  'name'     => $prereq_name,
                  'version'  => $prereq_version,
                  'release'  => $prereq_release,
              );
  
              $self->install_package(
                  $prereq, $dir,
                  { %{$opts}, 'as_prereq' => 1 },
              );
          }
      }
  
      foreach my $item ( $full_parcel_dir->children ) {
          my $basename = $item->basename;
  
          $basename eq PARCEL_METADATA_FILE()
              and next;
  
          my $target_dir = $dir->child($basename);
          dircopy( $item, $target_dir );
      }
  
      Pakket::InfoFile::add_package( $parcel_dir, $dir, $full_package, $opts );
  
      log_success( sprintf 'Delivering parcel %s', $full_package->full_name );
  
      return;
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
PAKKET_INSTALLER

$fatpacked{"Pakket/LibDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_LIBDIR';
  package Pakket::LibDir;
  
  # ABSTRACT: Function to work with lib directory
  
  use Path::Tiny qw< path  >;
  use File::Copy::Recursive qw< dircopy >;
  use Time::HiRes qw< time >;
  use Log::Any qw< $log >;
  use English qw< -no_match_vars >;
  
  sub get_libraries_dir {
      my $lib_dir = shift;
  
      my $libraries_dir = $lib_dir->child('libraries');
  
      $libraries_dir->is_dir
          or $libraries_dir->mkpath();
  
      return $libraries_dir;
  }
  
  sub get_active_dir {
      my $lib_dir = shift;
  
      my $active_dir = get_libraries_dir($lib_dir)->child('active');
  
      return $active_dir;
  }
  
  sub create_new_work_dir {
      my $pakket_dir = shift;
  
      my $pakket_libraries_dir = get_libraries_dir($pakket_dir);
  
      my $work_dir = $pakket_libraries_dir->child( time() );
  
      if ( $work_dir->exists ) {
          die $log->critical(
              "Internal installation directory exists ($work_dir), exiting",
          );
      }
  
      $work_dir->mkpath();
  
      my $active_link = get_active_dir($pakket_dir);
  
      # we copy any previous installation
      if ( $active_link->exists ) {
          my $orig_work_dir = eval { my $link = readlink $active_link } or do {
              die $log->critical("$active_link is not a symlink");
          };
  
          dircopy( $pakket_libraries_dir->child($orig_work_dir), $work_dir );
      }
      $log->debugf( 'Created new working directory %s', $work_dir );
      return $work_dir;
  }
  
  sub activate_work_dir {
      my $work_dir = shift;
  
      unless ( $work_dir->exists ) {
          die $log->critical("Directory $work_dir doesn't exist");
      }
  
      my $pakket_libraries_dir = $work_dir->parent;
  
      # The only way to make a symlink point somewhere else in an atomic way is
      # to create a new symlink pointing to the target, and then rename it to the
      # existing symlink (that is, overwriting it).
      #
      # This actually works, but there is a caveat: how to generate a name for
      # the new symlink? File::Temp will both create a new file name and open it,
      # returning a handle; not what we need.
      #
      # So, we just create a file name that looks like 'active_P_T.tmp', where P
      # is the pid and T is the current time.
      my $active_link = $pakket_libraries_dir->child('active');
      my $active_temp
          = $pakket_libraries_dir->child(
          sprintf( 'active_%s_%s.tmp', $PID, time() ),
          );
  
      if ( $active_temp->exists ) {
  
          # Huh? why does this temporary pathname exist? Try to delete it...
          $log->debug('Deleting existing temporary active object');
          if ( !$active_temp->remove ) {
              die $log->error(
                  'Could not activate new installation (temporary symlink remove failed)'
              );
          }
      }
  
      $log->debugf( 'Setting temporary active symlink to new work directory %s',
          $work_dir );
      if ( !symlink $work_dir->basename, $active_temp ) {
          die $log->error(
              'Could not activate new installation (temporary symlink create failed)'
          );
      }
      if ( !$active_temp->move($active_link) ) {
          die $log->error(
              'Could not atomically activate new installation (symlink rename failed)'
          );
      }
  }
  
  sub remove_old_libraries {
      my $lib_dir              = shift;
      my $pakket_libraries_dir = get_libraries_dir($lib_dir);
  
      my $keep = 1;
  
      my @dirs = sort { $a->stat->mtime <=> $b->stat->mtime }
          grep +( $_->basename ne 'active' && $_->is_dir ),
          $pakket_libraries_dir->children;
  
      my $num_dirs = @dirs;
      foreach my $dir (@dirs) {
          $num_dirs-- <= $keep and last;
          $log->debug("Removing old directory: $dir");
          path($dir)->remove_tree( { 'safe' => 0 } );
      }
  }
  
  1;
  
  __END__
PAKKET_LIBDIR

$fatpacked{"Pakket/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_LOG';
  package Pakket::Log;
  # ABSTRACT: A logger for Pakket
  
  use strict;
  use warnings;
  use parent 'Exporter';
  use Log::Dispatch;
  use Path::Tiny qw< path >;
  use Log::Any   qw< $log >;
  use Term::GentooFunctions qw< ebegin eend >;
  
  use constant {
      'DEBUG_LOG_LEVEL'    => 3,
      'DEBUG_INFO_LEVEL'   => 2,
      'DEBUG_NOTICE_LEVEL' => 1,
  
      'TERM_SIZE_MAX'     => 80,
      'TERM_EXTRA_SPACES' => ( length(' * ') + length(' [ ok ]') ),
  };
  
  # Just so I remember it:
  # 1  fatal     system unusable, aborts program!
  # 2  alert     failure in primary system
  # 3  critical  failure in backup system
  # 4  error     non-urgent program errors, a bug
  # 5  warning   possible problem, not necessarily error
  # 6  notice    unusual conditions
  # 7  info      normal messages, no action required
  # 8  debug     debugging messages for development
  # 9  trace     copious tracing output
  
  our @EXPORT_OK = qw< log_success log_fail >; ## no critic qw(Modules::ProhibitAutomaticExportation)
  
  sub _extra_spaces {
      my $msg = shift;
      return abs( TERM_SIZE_MAX() - ( length($msg) + TERM_EXTRA_SPACES() ) );
  }
  
  sub _log_to_outputs {
      my ( $msg, $status ) = @_;
      my $status_output = $status ? ' [ ok ]' : ' [ !! ]';
      my @log_outputs   = $log->adapter->{'dispatcher'}->outputs;
  
      foreach my $output (@log_outputs) {
          if ( ref($output) =~ m{^Log::Dispatch::Screen}xms ) {
              ebegin $msg;
              eend 1;
              next;
          }
  
          my $level   = $status ? 'info' : 'error';
          my $message = " * $msg" . ' ' x _extra_spaces($msg) . $status_output;
  
          $output->log(
              'level'   => $level,
              'message' => $message,
          );
      }
  
      return $msg;
  }
  
  sub log_success {
      my $msg = shift;
      return _log_to_outputs( $msg, 1 );
  }
  
  sub log_fail {
      my $msg = shift;
      return _log_to_outputs( $msg, 0 );
  }
  
  sub arg_default_logger {
      return $_[1] || Log::Dispatch->new(
          'outputs' => [
              [
                  'Screen',
                  'min_level' => 'notice',
                  'newline'   => 1,
              ],
          ],
      );
  }
  
  sub build_logger {
      my ( $class, $verbose, $file ) = @_;
      my $logger = Log::Dispatch->new(
          'outputs' => [
              $class->_build_logger($file),
              $class->_cli_logger( $verbose // 1 ),
          ],
      );
  
      return $logger;
  }
  
  sub _build_logger {
      my $file = shift || Path::Tiny->cwd->child('build.log')->stringify;
  
      return [
          'File',
          'min_level' => 'debug',
          'filename'  => $file,
          'newline'   => 1,
      ];
  }
  
  sub cli_logger {
      my ( $class, $verbose ) = @_;
  
      my $logger = Log::Dispatch->new(
          'outputs' => [ $class->_cli_logger($verbose) ],
      );
  
      return $logger;
  }
  
  sub _cli_logger {
      my ( $class, $verbose ) = @_;
  
      $verbose ||= 0;
  
      my $screen_level =
          $verbose >= +DEBUG_LOG_LEVEL    ? 'debug'  : # log 2
          $verbose == +DEBUG_INFO_LEVEL   ? 'info'   : # log 1
          $verbose == +DEBUG_NOTICE_LEVEL ? 'notice' : # log 0
                                            'warning';
      return [
          'Screen::Gentoo',
          'min_level' => $screen_level,
          'newline'   => 1,
          'utf8'      => 1,
      ];
  }
  
  1;
  
  __END__
PAKKET_LOG

$fatpacked{"Pakket/Manager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_MANAGER';
  package Pakket::Manager;
  # ABSTRACT: Manage pakket packages and repos
  
  use Moose;
  use Log::Any qw< $log >;
  
  use Pakket::Log;
  use Pakket::Scaffolder::Perl;
  
  has config => (
      is        => 'ro',
      isa       => 'HashRef',
      default   => sub { +{} },
  );
  
  has category => (
      is        => 'ro',
      isa       => 'Str',
      lazy      => 1,
      builder   => '_build_category',
  );
  
  has cache_dir => (
      is        => 'ro',
      isa       => 'Maybe[Str]',
  );
  
  has cpanfile => (
      is        => 'ro',
      isa       => 'Maybe[Str]',
  );
  
  has package => (
      is        => 'ro',
      isa       => 'Maybe[Pakket::Package]',
  );
  
  has phases => (
      is        => 'ro',
      isa       => 'Maybe[ArrayRef]',
  );
  
  has file_02packages => (
      is        => 'ro',
      isa       => 'Maybe[Str]',
  );
  
  sub _build_category {
      my $self = shift;
      $self->{'cpanfile'} and return 'perl';
      return $self->package->category;
  }
  
  sub list_ids {
      my ( $self, $type ) = @_;
      my $repo = $self->_get_repo($type);
      print "$_\n" for sort @{ $repo->all_object_ids };
  }
  
  sub show_package_config {
      my $self = shift;
      my $repo = $self->_get_repo('spec');
      my $spec = $repo->retrieve_package_spec( $self->package );
  
      my ( $category, $name, $version, $release ) =
          @{ $spec->{'Package'} }{qw< category name version release >};
  
      print <<"SHOW";
  
  # PACKAGE:
  
  category: $category
  name:     $name
  version:  $version
  release:  $release
  
  # DEPENDENCIES:
  
  SHOW
  
      for my $c ( sort keys %{ $spec->{'Prereqs'} } ) {
          for my $p ( sort keys %{ $spec->{'Prereqs'}{$c} } ) {
              print "$c/$p:\n";
              for my $n ( sort keys %{ $spec->{'Prereqs'}{$c}{$p} } ) {
                  my $v = $spec->{'Prereqs'}{$c}{$p}{$n}{'version'};
                  print "- $n-$v\n";
              }
              print "\n";
          }
      }
  
      # TODO: reverse dependencies (requires map)
  }
  
  sub add_package {
      my $self = shift;
      $self->_get_scaffolder->run;
  }
  
  sub remove_package_source {
      my $self = shift;
      my $repo = $self->_get_repo('source');
      $repo->remove_package_source( $self->package );
      $log->info( sprintf("Removed %s from the source repo.", $self->package->id ) );
  }
  
  sub remove_package_spec {
      my $self = shift;
      my $repo = $self->_get_repo('spec');
      $repo->remove_package_spec( $self->package );
      $log->info( sprintf("Removed %s from the spec repo.", $self->package->id ) );
  }
  
  sub add_dependency {
      my ( $self, $dependency ) = @_;
      $self->_package_dependency_edit($dependency, 'add');
  }
  
  sub remove_dependency {
      my ( $self, $dependency ) = @_;
      $self->_package_dependency_edit($dependency, 'remove');
  }
  
  sub _package_dependency_edit {
      my ( $self, $dependency, $cmd ) = @_;
      my $repo = $self->_get_repo('spec');
      my $spec = $repo->retrieve_package_spec( $self->package );
  
      my $dep_name    = $dependency->{'name'};
      my $dep_version = $dependency->{'version'};
  
      my ( $category, $phase ) = @{$dependency}{qw< category phase >};
  
      my $dep_exists = ( defined $spec->{'Prereqs'}{$category}{$phase}{$dep_name}
                             and $spec->{'Prereqs'}{$category}{$phase}{$dep_name}{'version'} eq $dep_version );
  
      my $name = $self->package->name;
  
      if ( $cmd eq 'add' ) {
          if ( $dep_exists ) {
              $log->info( sprintf("%s is already a %s dependency for %s.",
                                  $dep_name, $phase, $name) );
              exit 1;
          }
  
          $spec->{'Prereqs'}{$category}{$phase}{$dep_name} = +{
              version => $dep_version
          };
  
          $log->info( sprintf("Added %s as %s dependency for %s.",
                              $dep_name, $phase, $name) );
  
      } elsif ( $cmd eq 'remove' ) {
          if ( !$dep_exists ) {
              $log->info( sprintf("%s is not a %s dependency for %s.",
                                  $dep_name, $phase, $name) );
              exit 1;
          }
  
          delete $spec->{'Prereqs'}{$category}{$phase}{$dep_name};
  
          $log->info( sprintf("Removed %s as %s dependency for %s.",
                              $dep_name, $phase, $name) );
      }
  
      $repo->store_package_spec($self->package, $spec);
  }
  
  sub _get_repo {
      my ( $self, $key ) = @_;
      my $class = 'Pakket::Repository::' . ucfirst($key);
      return $class->new(
          'backend' => $self->config->{'repositories'}{$key},
      );
  }
  
  sub _get_scaffolder {
      my $self = shift;
  
      $self->category eq 'perl'
          and return $self->_gen_scaffolder_perl;
  
      die "failed to create a scaffolder\n";
  }
  
  sub _gen_scaffolder_perl {
      my $self = shift;
  
      my %params = (
          'config' => $self->config,
          'phases' => $self->phases,
      );
  
      if ( $self->cpanfile ) {
          $params{'cpanfile'} = $self->cpanfile;
  
      } else {
          $params{'module'}  = $self->package->name;
          $params{'version'} = defined $self->package->version
              # hack to pass exact version in prereq syntax
              ? '=='.$self->package->version
              : undef;
      }
  
      $self->cache_dir
          and $params{'cache_dir'} = $self->cache_dir;
  
      $self->file_02packages
          and $params{'file_02packages'} = $self->file_02packages;
  
      return Pakket::Scaffolder::Perl->new(%params);
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
PAKKET_MANAGER

$fatpacked{"Pakket/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_PACKAGE';
  package Pakket::Package;
  # ABSTRACT: An object representing a package
  
  use Moose;
  use MooseX::StrictConstructor;
  use Pakket::Types;
  use Pakket::Constants qw< PAKKET_DEFAULT_RELEASE >;
  use JSON::MaybeXS qw< decode_json >;
  
  with qw< Pakket::Role::BasicPackageAttrs >;
  
  has [ qw< name category version release > ] => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'is_bootstrap' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {0},
  );
  
  has [qw<build_opts bundle_opts>] => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'prereqs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { return +{} },
  );
  
  # FIXME: GH #73 will make this more reasonable
  has 'configure_prereqs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_configure_prereqs',
  );
  
  has 'test_prereqs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_test_prereqs',
  );
  
  has 'runtime_prereqs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_runtime_prereqs',
  );
  
  sub _build_configure_prereqs {
      my $self    = shift;
      return $self->phase_prereqs('configure');
  }
  
  sub _build_test_prereqs {
      my $self    = shift;
      return $self->phase_prereqs('test');
  }
  
  sub _build_runtime_prereqs {
      my $self    = shift;
      return $self->phase_prereqs('runtime');
  }
  
  sub phase_prereqs {
      my ( $self, $phase ) = @_;
      my $prereqs = $self->prereqs;
      return +{
          map { $_ => $prereqs->{$_}{$phase} }
              keys %{$prereqs},
      };
  }
  
  sub spec {
      my $self = shift;
  
      return +{
          'Package' => {
              # This is so we don't see is_bootstrap in spec
              # if not required -- SX
              ( 'is_bootstrap' => 1 )x!! $self->is_bootstrap,
  
              map +( $_ => $self->$_ ), qw<category name version release>,
          },
  
          'Prereqs' => $self->prereqs,
  
          map +( $_ => $self->$_ ), qw<build_opts bundle_opts>,
      };
  }
  
  sub new_from_spec {
      my ( $class, $spec ) = @_;
  
      my %package_details = (
          %{ $spec->{'Package'} },
          'prereqs'      => $spec->{'Prereqs'}    || {},
          'build_opts'   => $spec->{'build_opts'} || {},
          'is_bootstrap' => !!$spec->{'is_bootstrap'},
      );
  
      return $class->new(%package_details);
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
PAKKET_PACKAGE

$fatpacked{"Pakket/Repository.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY';
  package Pakket::Repository;
  # ABSTRACT: Build in-memory representation of repo
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Path::Tiny;
  use Archive::Any;
  use Archive::Tar::Wrapper;
  use Carp ();
  use Log::Any      qw< $log >;
  use Pakket::Types qw< PakketRepositoryBackend >;
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC >;
  use Pakket::Versioning;
  
  has 'backend' => (
      'is'      => 'ro',
      'does'    => 'PakketRepositoryBackend',
      'coerce'  => 1,
      'lazy'    => 1,
      'builder' => '_build_backend',
      'handles' => [ qw<
          all_object_ids has_object
          store_content  retrieve_content  remove_content
          store_location retrieve_location remove_location
      > ],
  );
  
  sub _build_backend {
      my $self = shift;
      die $log->critical(
          'You did not specify a backend '
        . '(using parameter or builder)',
      );
  }
  
  sub BUILD {
      my $self = shift;
      $self->backend();
  }
  
  sub retrieve_package_file {
      my ( $self, $type, $package ) = @_;
      my $file = $self->retrieve_location( $package->id );
  
      if ( !$file ) {
          die $log->criticalf(
              'We do not have the %s for package %s',
              $type, $package->full_name,
          );
      }
  
      my $dir = Path::Tiny->tempdir( 'CLEANUP' => 1 );
      my $arch = Archive::Any->new( $file->stringify );
      $arch->extract($dir);
  
      return $dir;
  }
  
  sub remove_package_file {
      my ( $self, $type, $package ) = @_;
      my $file = $self->retrieve_location( $package->id );
  
      if ( !$file ) {
          die $log->criticalf(
              'We do not have the %s for package %s',
              $type, $package->full_name,
          );
      }
  
      $log->debug("Removing $type package");
      $self->remove_location( $package->id );
  }
  
  sub latest_version_release {
      my ( $self, $category, $name, $req_string ) = @_;
  
      # This will also convert '0' to '>= 0'
      # (If we want to disable it, we just can just //= instead)
      $req_string ||= '>= 0';
  
      # Category -> Versioning type class
      my %types = (
          'perl' => 'Perl',
      );
  
      my @versions;
      foreach my $object_id ( @{ $self->all_object_ids } ) {
          my ( $my_category, $my_name, $my_version, $my_release ) =
              $object_id =~ PAKKET_PACKAGE_SPEC();
  
          # Ignore what is not ours
          $category eq $my_category and $name eq $my_name
              or next;
  
          # Add the version
          push @versions, $my_version;
      }
  
      my $versioner = Pakket::Versioning->new(
          'type' => $types{$category},
      );
  
      my $latest_version = $versioner->latest( $req_string, @versions );
      $latest_version
          and return [ $latest_version, 1 ];
  
      Carp::croak( $log->criticalf(
          'Could not analyze %s/%s to find latest version',
          $category, $name,
      ) );
  }
  
  sub freeze_location {
      my ( $self, $orig_path ) = @_;
  
      my $arch = Archive::Tar::Wrapper->new();
  
      if ( $orig_path->is_file ) {
          $arch->add( $orig_path->basename, $orig_path->stringify, );
      } elsif ( $orig_path->is_dir ) {
          $orig_path->children
              or
              die $log->critical("Cannot freeze empty directory ($orig_path)");
  
          $orig_path->visit(
              sub {
                  my ( $path, $stash ) = @_;
  
                  $path->is_file
                      or return;
  
                  $arch->add( $path->relative($orig_path)->stringify,
                      $path->stringify, );
              },
              { 'recurse' => 1 },
          );
      } else {
          die $log->criticalf( "Unknown location type: %s", $orig_path );
      }
  
      my $file = Path::Tiny->tempfile();
  
      # Write and compress
      $log->debug("Writing archive as $file");
      $arch->write( $file->stringify, 1 );
  
      return $file;
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
  
  =pod
PAKKET_REPOSITORY

$fatpacked{"Pakket/Repository/Backend/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_BACKEND_DBI';
  package Pakket::Repository::Backend::DBI;
  # ABSTRACT: A DBI-based backend repository
  
  # FIXME: Add methods: remove_location, remove_content
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use DBI        qw< :sql_types >;
  use Types::DBI;
  use Path::Tiny qw< path >;
  use Log::Any   qw< $log >;
  
  with qw<
      Pakket::Role::Repository::Backend
  >;
  
  has 'dbh' => (
     'is'       => 'ro',
     'isa'      => Dbh,
     'required' => 1,
     'coerce'   => 1,
  );
  
  ## no critic qw(Variables::ProhibitPackageVars)
  sub all_object_ids {
      my $self = shift;
      my $sql  = q{SELECT id FROM data};
      my $stmt = $self->_prepare_statement($sql);
  
      if ( !$stmt->execute() ) {
          die $log->criticalf(
              'Could not get remote all_object_ids: %s',
              $DBI::errstr,
          );
      }
  
      my @all_object_ids = map +( $_->[0] ), @{ $stmt->fetchall_arrayref() };
      return \@all_object_ids;
  }
  
  sub _prepare_statement {
      my ( $self, $sql ) = @_;
      my $stmt = $self->dbh->prepare($sql);
  
      if ( !$stmt ) {
          die $log->criticalf(
              'Could not prepare statement [%s] => %s',
              $sql,
              $DBI::errstr,
          );
      }
  
      return $stmt;
  }
  
  sub has_object {
      my ( $self, $id ) = @_;
      my $sql  = q{ SELECT id FROM data WHERE id = ? };
      my $stmt = $self->_prepare_statement($sql);
  
      $stmt->bind_param( 1, $id, SQL_VARCHAR );
      if ( !$stmt->execute() ) {
          die $log->criticalf(
              'Could not retrieve content for id %d: %s',
              $id,
              $DBI::errstr,
          );
      }
  
      my $results = $stmt->fetchall_arrayref();
      return @{$results} == 1;
  }
  
  sub store_location {
      my ( $self, $id, $file_to_store ) = @_;
      my $content = path($file_to_store)->slurp( { 'binmode' => ':raw' } );
      $self->store_content( $id, $content );
  }
  
  sub retrieve_location {
      my ( $self, $id ) = @_;
      my $content = $self->retrieve_content->($id);
      my $location = Path::Tiny->tempfile;
      $location->spew( { 'binmode' => ':raw' }, $content );
      return $location;
  }
  
  sub store_content {
      my ( $self, $id, $content ) = @_;
      {
          my $sql  = q{DELETE FROM data WHERE id = ?};
          my $stmt = $self->_prepare_statement($sql);
  
          $stmt->bind_param( 1, $id, SQL_VARCHAR );
          if ( !$stmt->execute() ) {
              die $log->criticalf(
                  'Could not delete content for id %d: %s',
                  $id,
                  $DBI::errstr,
              );
          }
      }
      {
          my $sql  = q{INSERT INTO data (id, content) VALUES (?, ?)};
          my $stmt = $self->_prepare_statement($sql);
  
          $stmt->bind_param( 1, $id,      SQL_VARCHAR );
          $stmt->bind_param( 2, $content, SQL_BLOB );
          if ( !$stmt->execute() ) {
              die $log->criticalf(
                  'Could not insert content for id %d: %s',
                  $id,
                  $DBI::errstr,
              );
          }
      }
  }
  
  sub retrieve_content {
      my ( $self, $id ) = @_;
      my $sql  = q{SELECT content FROM data WHERE id = ?};
      my $stmt = $self->_prepare_statement($sql);
  
      $stmt->bind_param(1, $id, SQL_VARCHAR);
      if ( !$stmt->execute() ) {
          die $log->criticalf(
              'Could not retrieve content for id %d: %s',
              $id,
              $DBI::errstr,
          );
      }
  
      my $all_content = $stmt->fetchall_arrayref();
      if ( !$all_content || @{$all_content} != 1 ) {
          die $log->criticalf(
              'Failed to retrieve exactly one row for id %d: %s',
              $id,
          );
      }
  
      return $all_content->[0];
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
  
  =pod
PAKKET_REPOSITORY_BACKEND_DBI

$fatpacked{"Pakket/Repository/Backend/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_BACKEND_FILE';
  package Pakket::Repository::Backend::File;
  # ABSTRACT: A file-based backend repository
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use JSON::MaybeXS     qw< decode_json >;
  use Path::Tiny        qw< path >;
  use Log::Any          qw< $log >;
  use Types::Path::Tiny qw< Path AbsPath >;
  use Digest::SHA       qw< sha1_hex >;
  use Pakket::Utils     qw< encode_json_canonical encode_json_pretty >;
  
  with qw<
      Pakket::Role::Repository::Backend
  >;
  
  has 'directory' => (
      'is'       => 'ro',
      'isa'      => AbsPath,
      'coerce'   => 1,
      'required' => 1,
  );
  
  has 'file_extension' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {'sgm'},
  );
  
  has 'index_file' => (
      'is'       => 'ro',
      'isa'      => Path,
      'coerce'   => 1,
      'default'  => sub {
          my $self = shift;
          return $self->directory->child('index.json');
      },
  );
  
  has 'repo_index' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'builder' => '_build_repo_index',
  );
  
  has 'pretty_json' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {1},
  );
  
  sub _build_repo_index {
      my $self = shift;
      my $file = $self->index_file;
  
      $file->is_file
          or return +{};
  
      return decode_json( $file->slurp_utf8 );
  }
  
  sub all_object_ids {
      my $self           = shift;
      my @all_object_ids = keys %{ $self->repo_index };
      return \@all_object_ids;
  }
  
  sub has_object {
      my ( $self, $id ) = @_;
      return exists $self->repo_index->{$id};
  }
  
  sub _store_in_index {
      my ( $self, $id ) = @_;
  
      # Decide on a proper filename for $id
      # Meaningless extension
      my $filename = sha1_hex($id) . '.' . $self->file_extension;
  
      # Store in the index
      $self->repo_index->{$id} = $filename;
  
      $self->_save_index();
  
      return $filename;
  }
  
  sub _save_index {
      my $self = shift;
  
      my $content
          = $self->pretty_json
          ? encode_json_pretty( $self->repo_index )
          : encode_json_canonical( $self->repo_index );
  
      $self->index_file->spew_utf8($content);
  }
  
  sub _retrieve_from_index {
      my ( $self, $id ) = @_;
      return $self->repo_index->{$id};
  }
  
  sub _remove_from_index {
      my ( $self, $id ) = @_;
      delete $self->repo_index->{$id};
      $self->_save_index();
  }
  
  sub store_location {
      my ( $self, $id, $file_to_store ) = @_;
      my $filename  = $self->_store_in_index($id);
      my $directory = $self->directory;
  
      return path($file_to_store)->copy( $directory->child($filename) );
  }
  
  sub retrieve_location {
      my ( $self, $id ) = @_;
      my $filename = $self->_retrieve_from_index($id);
      $filename
          and return $self->directory->child($filename);
  
      $log->debug("File for ID '$id' does not exist in storage");
      return;
  }
  
  sub remove_location {
      my ( $self, $id ) = @_;
      my $location = $self->retrieve_location($id);
      $location or return;
      $location->remove;
      $self->_remove_from_index($id);
      return 1;
  }
  
  sub store_content {
      my ( $self, $id, $content ) = @_;
      my $file_to_store = Path::Tiny->tempfile;
      $file_to_store->spew( { 'binmode' => ':raw' }, $content );
      return $self->store_location( $id, $file_to_store );
  }
  
  sub retrieve_content {
      my ( $self, $id ) = @_;
      return $self->retrieve_location($id)
                  ->slurp_utf8( { 'binmode' => ':raw' } );
  }
  
  sub remove_content {
      my ( $self, $id ) = @_;
      return $self->remove_location($id);
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
  
  =pod
PAKKET_REPOSITORY_BACKEND_FILE

$fatpacked{"Pakket/Repository/Backend/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_BACKEND_HTTP';
  package Pakket::Repository::Backend::HTTP;
  # ABSTRACT: A remote HTTP backend repository
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use URI::Escape       qw< uri_escape >;
  use JSON::MaybeXS     qw< decode_json >;
  use Path::Tiny        qw< path >;
  use Log::Any          qw< $log >;
  use Types::Path::Tiny qw< Path >;
  use HTTP::Tiny;
  use Pakket::Utils     qw< encode_json_canonical >;
  
  with qw<
      Pakket::Role::Repository::Backend
  >;
  
  has 'host' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'port' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'base_url' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'lazy'     => 1,
      'builder'  => '_build_base_url',
  );
  
  has 'base_path' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {''},
  );
  
  has 'http_client' => (
      'is'       => 'ro',
      'isa'      => 'HTTP::Tiny',
      'default'  => sub { HTTP::Tiny->new },
  );
  
  sub _build_base_url {
      my $self = shift;
      return sprintf(
          'http://%s:%s%s', $self->host, $self->port, $self->base_path,
      );
  }
  
  sub all_object_ids {
      my $self     = shift;
      my $url      = '/all_object_ids';
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
  
      if ( !$response->{'success'} ) {
          die $log->criticalf( 'Could not get remote all_object_ids: %d -- %s',
              $response->{'status'}, $response->{'reason'} );
      }
  
      my $content = decode_json( $response->{'content'} );
      return $content->{'object_ids'};
  }
  
  sub has_object {
      my ( $self, $id ) = @_;
      my $response = $self->http_client->get(
          $self->base_url . '/has_object?id=' . uri_escape($id),
      );
  
      if ( !$response->{'success'} ) {
          die $log->criticalf( 'Could not get remote has_object: %d -- %s',
              $response->{'status'}, $response->{'reason'} );
      }
  
      my $content = decode_json( $response->{'content'} );
      return $content->{'has_object'};
  }
  
  sub store_location {
      my ( $self, $id, $file_to_store ) = @_;
      my $content = path($file_to_store)->slurp(
          { 'binmode' => ':raw' },
      );
  
      my $url = "/store/location?id=" . uri_escape($id);
      my $full_url = $self->base_url . $url;
  
      my $response = $self->http_client->post(
          $full_url => {
              'content' => $content,
              'headers' => {
                  'Content-Type' => 'application/x-www-form-urlencoded',
              },
          },
      );
  
      if ( !$response->{'success'} ) {
          die $log->criticalf( 'Could not store location for id %s', $id );
      }
  }
  
  sub retrieve_location {
      my ( $self, $id ) = @_;
      my $url      = '/retrieve/location?id=' . uri_escape($id);
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
      $response->{'success'} or return;
      my $content  = $response->{'content'};
      my $location = Path::Tiny->tempfile;
      $location->spew( { 'binmode' => ':raw' }, $content );
      return $location;
  }
  
  sub store_content {
      my ( $self, $id, $content ) = @_;
      my $url      = "/store/content";
      my $full_url = $self->base_url . $url;
  
      my $response = $self->http_client->post(
          $full_url => {
              'content' => encode_json_canonical(
                  { 'content' => $content, 'id' => $id, },
              ),
  
              'headers' => {
                  'Content-Type' => 'application/json',
              },
          },
      );
  
      if ( !$response->{'success'} ) {
          die $log->criticalf( 'Could not store content for id %s', $id );
      }
  }
  
  sub retrieve_content {
      my ( $self, $id ) = @_;
      my $url      = '/retrieve/content?id=' . uri_escape($id);
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
  
      if ( !$response->{'success'} ) {
          die $log->criticalf( 'Could not retrieve content for id %s', $id );
      }
  
      return $response->{'content'};
  }
  
  sub remove_location {
      my ( $self, $id ) = @_;
      my $url = '/remove/location?id=' . uri_escape($id);
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
      return $response->{'success'};
  }
  
  sub remove_content {
      my ( $self, $id ) = @_;
      my $url = '/remove/content?id=' . uri_escape($id);
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
      return $response->{'success'};
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
  
  =pod
PAKKET_REPOSITORY_BACKEND_HTTP

$fatpacked{"Pakket/Repository/Parcel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_PARCEL';
  package Pakket::Repository::Parcel;
  # ABSTRACT: A parcel repository
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Log::Any qw< $log >;
  use Path::Tiny;
  
  extends qw< Pakket::Repository >;
  
  sub retrieve_package_parcel {
      my ( $self, $package ) = @_;
      return $self->retrieve_package_file( 'parcel', $package );
  }
  
  sub store_package_parcel {
      my ( $self, $package, $parcel_path ) = @_;
  
      $log->debug("Adding $parcel_path to file");
      my $file = $self->freeze_location($parcel_path);
  
      $log->debug("Storing $file");
      $self->store_location( $package->id, $file );
  }
  
  sub remove_package_parcel {
      my ( $self, $package ) = @_;
      return $self->remove_package_file( 'parcel', $package );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_REPOSITORY_PARCEL

$fatpacked{"Pakket/Repository/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_SOURCE';
  package Pakket::Repository::Source;
  # ABSTRACT: A source repository
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Log::Any qw< $log >;
  use Path::Tiny;
  
  extends qw< Pakket::Repository >;
  
  sub retrieve_package_source {
      my ( $self, $package ) = @_;
      return $self->retrieve_package_file( 'source', $package );
  }
  
  sub store_package_source {
      my ( $self, $package, $source_path ) = @_;
  
      $log->debug("Adding $source_path to file");
      my $file = $self->freeze_location($source_path);
  
      $log->debug("Storing $file");
      $self->store_location( $package->id, $file );
  }
  
  sub remove_package_source {
      my ( $self, $package ) = @_;
      return $self->remove_package_file( 'source', $package );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_REPOSITORY_SOURCE

$fatpacked{"Pakket/Repository/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_SPEC';
  package Pakket::Repository::Spec;
  # ABSTRACT: A spec repository
  
  use Moose;
  use MooseX::StrictConstructor;
  use Types::Path::Tiny qw< Path >;
  use Carp              qw< croak >;
  use JSON::MaybeXS     qw< decode_json >;
  use Pakket::Utils     qw< encode_json_pretty >;
  
  extends qw< Pakket::Repository >;
  
  sub retrieve_package_spec {
      my ( $self, $package ) = @_;
  
      my $spec_str = $self->retrieve_content(
          $package->id,
      );
  
      my $config;
      eval {
          my $config_raw = decode_json($spec_str);
          $config = decode_json $config_raw->{'content'};
          1;
      } or do {
          my $err = $@ || 'Unknown error';
          croak("Cannot read spec properly: $err");
      };
  
      return $config;
  }
  
  sub store_package_spec {
      my ( $self, $package, $spec ) = @_;
  
      return $self->store_content(
          $package->id,
          encode_json_pretty( $spec || $package->spec ),
      );
  }
  
  sub remove_package_spec {
      my ( $self, $package ) = @_;
      return $self->remove_package_file( 'spec', $package );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_REPOSITORY_SPEC

$fatpacked{"Pakket/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REQUIREMENT';
  package Pakket::Requirement;
  # ABSTRACT: A Pakket requirement
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Log::Any          qw< $log >;
  use Pakket::Constants qw<
      PAKKET_PACKAGE_SPEC
      PAKKET_DEFAULT_RELEASE
  >;
  use Pakket::Types;
  
  with qw< Pakket::Role::BasicPackageAttrs >;
  
  has [qw< category name >] => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'version' => (
      'is'       => 'ro',
      'isa'      => 'PakketVersion',
      'coerce'   => 1,
      'required' => 1,
  );
  
  has 'release' => (
      'is'      => 'ro',
      'isa'     => 'PakketRelease',
      'coerce'  => 1,
      'default' => sub { PAKKET_DEFAULT_RELEASE() },
  );
  
  has 'is_bootstrap' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {0},
  );
  
  sub new_from_string {
      my ( $class, $req_str ) = @_;
  
      if ( $req_str !~ PAKKET_PACKAGE_SPEC() ) {
          die $log->critical("Cannot parse $req_str");
      } else {
          # This shuts up Perl::Critic
          return $class->new(
              'category' => $1,
              'name'     => $2,
              'version'  => $3,
              ( 'release'  => $4 )x!! $4,
          );
      }
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_REQUIREMENT

$fatpacked{"Pakket/Role/BasicPackageAttrs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_BASICPACKAGEATTRS';
  package Pakket::Role::BasicPackageAttrs;
  # ABSTRACT: Some helpers to print names nicely
  
  use Moose::Role;
  use Pakket::Utils qw< canonical_package_name >;
  
  sub short_name {
      my $self = shift;
      return canonical_package_name( $self->category, $self->name );
  }
  
  sub full_name {
      my $self = shift;
      return canonical_package_name(
          $self->category, $self->name, $self->version, $self->release,
      );
  }
  
  sub id {
      my $self = shift;
      return $self->full_name;
  }
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
PAKKET_ROLE_BASICPACKAGEATTRS

$fatpacked{"Pakket/Role/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_BUILDER';
  package Pakket::Role::Builder;
  
  # ABSTRACT: A role for all builders
  
  use Moose::Role;
  
  with qw< Pakket::Role::RunCommand >;
  
  requires qw< build_package >;
  
  no Moose::Role;
  
  1;
PAKKET_ROLE_BUILDER

$fatpacked{"Pakket/Role/HasConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASCONFIG';
  package Pakket::Role::HasConfig;
  # ABSTRACT: A role providing access to the Pakket configuration file
  
  use Moose::Role;
  use Pakket::Config;
  
  has 'config' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_config',
  );
  
  sub _build_config {
      my $self        = shift;
      my $config_reader = Pakket::Config->new();
      return $config_reader->read_config;
  }
  
  no Moose::Role;
  1;
  
  __END__
PAKKET_ROLE_HASCONFIG

$fatpacked{"Pakket/Role/HasParcelRepo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASPARCELREPO';
  package Pakket::Role::HasParcelRepo;
  # ABSTRACT: Provide parcel repo support
  
  use Moose::Role;
  use Pakket::Repository::Parcel;
  
  has 'parcel_repo' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Repository::Parcel',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          return Pakket::Repository::Parcel->new(
              'backend' => $self->parcel_repo_backend,
          );
      },
  );
  
  has 'parcel_repo_backend' => (
      'is'      => 'ro',
      'isa'     => 'PakketRepositoryBackend',
      'lazy'    => 1,
      'coerce'  => 1,
      'default' => sub {
          my $self = shift;
          return $self->config->{'repositories'}{'parcel'};
      },
  );
  
  no Moose::Role;
  1;
  __END__
PAKKET_ROLE_HASPARCELREPO

$fatpacked{"Pakket/Role/HasSourceRepo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASSOURCEREPO';
  package Pakket::Role::HasSourceRepo;
  # ABSTRACT: Provide source repo support
  
  use Moose::Role;
  use Pakket::Repository::Source;
  
  has 'source_repo' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Repository::Source',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          return Pakket::Repository::Source->new(
              'backend' => $self->source_repo_backend,
          );
      },
  );
  
  has 'source_repo_backend' => (
      'is'      => 'ro',
      'isa'     => 'PakketRepositoryBackend',
      'lazy'    => 1,
      'coerce'  => 1,
      'default' => sub {
          my $self = shift;
          return $self->config->{'repositories'}{'source'};
      },
  );
  
  no Moose::Role;
  1;
  __END__
PAKKET_ROLE_HASSOURCEREPO

$fatpacked{"Pakket/Role/HasSpecRepo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASSPECREPO';
  package Pakket::Role::HasSpecRepo;
  # ABSTRACT: Provide spec repo support
  
  use Moose::Role;
  use Pakket::Repository::Spec;
  
  has 'spec_repo' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Repository::Spec',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          return Pakket::Repository::Spec->new(
              'backend' => $self->spec_repo_backend,
          );
      },
  );
  
  has 'spec_repo_backend' => (
      'is'      => 'ro',
      'isa'     => 'PakketRepositoryBackend',
      'lazy'    => 1,
      'coerce'  => 1,
      'default' => sub {
          my $self = shift;
          return $self->config->{'repositories'}{'spec'};
      },
  );
  
  no Moose::Role;
  1;
  __END__
PAKKET_ROLE_HASSPECREPO

$fatpacked{"Pakket/Role/Perl/BootstrapModules.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_PERL_BOOTSTRAPMODULES';
  package Pakket::Role::Perl::BootstrapModules;
  # ABSTRACT: role to provide Perl's list of bootstrap modules (distributions)
  
  use Moose::Role;
  
  # hardcoded list of packages we have to build first
  # using core modules to break cyclic dependencies.
  # we have to maintain the order in order for packages to build
  has 'perl_bootstrap_modules' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'default' => sub {
          [qw<
              ExtUtils-MakeMaker
              Module-Build
              Module-Build-WithXSpp
              Module-Install
          >]
      },
  );
  
  no Moose::Role;
  1;
  __END__
PAKKET_ROLE_PERL_BOOTSTRAPMODULES

$fatpacked{"Pakket/Role/Repository/Backend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_REPOSITORY_BACKEND';
  package Pakket::Role::Repository::Backend;
  # ABSTRACT: A role for all repository backends
  
  use Moose::Role;
  
  # These are helper methods we want the backend to implement
  # in order for the Repository to easily use across any backend
  requires qw<
      all_object_ids has_object
  
      store_content  retrieve_content  remove_content
      store_location retrieve_location remove_location
  >;
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
PAKKET_ROLE_REPOSITORY_BACKEND

$fatpacked{"Pakket/Role/RunCommand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_RUNCOMMAND';
  package Pakket::Role::RunCommand;
  # ABSTRACT: Role for running commands
  
  use Moose::Role;
  use System::Command;
  use Path::Tiny qw< path >;
  use Log::Any   qw< $log >;
  
  sub run_command {
      my ( $self, $dir, $sys_cmds, $extra_opts ) = @_;
      $log->debug( join ' ', @{$sys_cmds} );
  
      my %opt = (
          'cwd' => path($dir)->stringify,
  
          %{ $extra_opts || {} },
  
          # 'trace' => $ENV{SYSTEM_COMMAND_TRACE},
      );
  
      my $cmd = System::Command->new( @{$sys_cmds}, \%opt );
  
      my $success = $cmd->loop_on(
          'stdout' => sub {
              my $msg = shift;
              chomp $msg;
              $log->debug($msg);
              1;
          },
  
          'stderr' => sub {
              my $msg = shift;
              chomp $msg;
              $log->notice($msg);
              1;
          },
      );
  
      $log->debugf(
          "Command '%s' exited with '%d'",
          join( ' ', $cmd->cmdline ),
          $cmd->exit,
      );
  
      return $success;
  }
  
  # does more or less the same as `command1 && command2 ... && commandN`
  sub run_command_sequence {
      my ( $self, @commands ) = @_;
  
      $log->debugf( 'Starting a sequence of %d commands', 0+@commands );
  
      for my $idx ( 0 .. $#commands ) {
          my $success = $self->run_command( @{ $commands[$idx] } );
          unless ($success) {
              $log->debug("Sequence terminated on item $idx");
              return;
          }
      }
  
      $log->debug('Sequence finished');
  
      return 1;
  }
  
  no Moose::Role;
  
  1;
  
  __END__
PAKKET_ROLE_RUNCOMMAND

$fatpacked{"Pakket/Role/Versioning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_VERSIONING';
  package Pakket::Role::Versioning;
  # ABSTRACT: A Versioning role
  
  use Moose::Role;
  
  requires qw< compare >;
  
  no Moose::Role;
  1;
PAKKET_ROLE_VERSIONING

$fatpacked{"Pakket/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_RUNNER';
  package Pakket::Runner;
  # ABSTRACT: Run Pakket-based applications
  
  use Moose;
  use Types::Path::Tiny qw< AbsPath >;
  
  has 'active_path' => (
      'is'       => 'ro',
      'isa'      => AbsPath,
      'coerce'   => 1,
      'required' => 1,
  );
  
  sub run {
      my ( $self, @args ) = @_;
  
      my $active_path = $self->active_path;
  
      # Avoid uninitialized values
      my $ENV_PATH            = $ENV{'PATH'}            // '';
      my $ENV_LD_LIBRARY_PATH = $ENV{'LD_LIBRARY_PATH'} // '';
  
      local $ENV{'PATH'}            = "$active_path/bin:$ENV_PATH";
      local $ENV{'PERL5LIB'}        = "$active_path/lib/perl5";
      local $ENV{'LD_LIBRARY_PATH'} = "$active_path/lib:$ENV_LD_LIBRARY_PATH";
  
      # FIXME: Move to IPC::Open3, use the logger, etc.
      # XXX:   Should this just use the RunCommand role?
      if (@args) {
          system @args;
      } else {
          print "$_=$ENV{$_}\n" for qw< PATH PERL5LIB LD_LIBRARY_PATH >;
      }
  
      return 0;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_RUNNER

$fatpacked{"Pakket/Scaffolder/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_PERL';
  package Pakket::Scaffolder::Perl;
  # ABSTRACT: Scffolding Perl distributions
  
  use Moose;
  use MooseX::StrictConstructor;
  use version 0.77;
  use Carp ();
  use Archive::Any;
  use CPAN::DistnameInfo;
  use CPAN::Meta::Prereqs;
  use JSON::MaybeXS       qw< decode_json encode_json >;
  use Ref::Util           qw< is_arrayref is_hashref >;
  use Path::Tiny          qw< path >;
  use Types::Path::Tiny   qw< Path  >;
  use Log::Any            qw< $log >;
  
  use Pakket::Package;
  use Pakket::Types;
  use Pakket::Utils::Perl qw< should_skip_module >;
  use Pakket::Scaffolder::Perl::Module;
  use Pakket::Scaffolder::Perl::CPANfile;
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasSpecRepo
      Pakket::Role::HasSourceRepo
      Pakket::Role::Perl::BootstrapModules
      Pakket::Scaffolder::Perl::Role::Borked
      Pakket::Scaffolder::Role::Backend
      Pakket::Scaffolder::Role::Terminal
  >;
  
  use constant {
      'ARCHIVE_DIR_TEMPLATE' => 'ARCHIVE-XXXXXX',
  };
  
  has 'metacpan_api' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'lazy'    => 1,
      'builder' => '_build_metacpan_api',
  );
  
  has 'phases' => (
      'is'       => 'ro',
      'isa'      => 'ArrayRef[PakketPhase]',
      'required' => 1,
  );
  
  has 'processed_dists' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { return +{} },
  );
  
  has 'modules' => (
      'is'  => 'ro',
      'isa' => 'HashRef',
  );
  
  has 'spec_index' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_spec_index',
  );
  
  has 'prereqs' => (
      'is'      => 'ro',
      'isa'     => 'CPAN::Meta::Prereqs',
      'lazy'    => 1,
      'builder' => '_build_prereqs',
  );
  
  has 'download_dir' => (
      'is'      => 'ro',
      'isa'     => Path,
      'lazy'    => 1,
      'builder' => '_build_download_dir',
  );
  
  has 'cache_dir' => (
      'is'        => 'ro',
      'isa'       => Path,
      'coerce'    => 1,
      'predicate' => '_has_cache_dir',
  );
  
  has 'file_02packages' => (
      'is'      => 'ro',
      'isa'     => 'Str',
  );
  
  has 'cpan_02packages' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_cpan_02packages',
  );
  
  sub _build_metacpan_api {
      my $self = shift;
      return $ENV{'PAKKET_METACPAN_API'}
          || $self->config->{'perl'}{'metacpan_api'}
          || 'https://fastapi.metacpan.org';
  }
  
  sub _build_prereqs {
      my $self = shift;
      return CPAN::Meta::Prereqs->new( $self->modules );
  }
  
  sub _build_download_dir {
      my $self = shift;
      return Path::Tiny->tempdir( 'CLEANUP' => 1 );
  }
  
  sub _build_spec_index {
      my $self = shift;
      my $spec_index = $self->spec_repo->all_object_ids;
      my %spec_index;
      for ( @{ $spec_index } ) {
          m{^.*?/(.*)=(.*?)$};
          $spec_index{$1}{$2} = 1;
      }
      return \%spec_index;
  }
  
  sub _build_cpan_02packages {
      my $self = shift;
      my $ret  = +{};
      my ( $dir, $file );
  
      if ( $self->file_02packages ) {
          $file = path( $self->file_02packages );
          $log->infof( "Using 02packages file: %s", $self->file_02packages );
  
      } else {
          $dir  = Path::Tiny->tempdir;
          $file = path( $dir, '02packages.details.txt' );
          $log->infof( "Downloading 02packages" );
          $self->ua->mirror( 'https://cpan.metacpan.org/modules/02packages.details.txt', $file );
      }
  
      chomp( my @content = $file->lines_utf8 );
      shift @content for 0..8; # remove headers
  
      for my $c ( @content ) {
          my ( $name, $latest, $path ) =
              $c =~ /^([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*$/;
  
          my $d = CPAN::DistnameInfo->new($path);
  
          $ret->{$name} = {
              'distribution'   => $d->dist,
              'latest_version' => $d->version,
          };
      }
  
      return $ret;
  }
  
  sub BUILDARGS {
      my ( $class, @args ) = @_;
      my %args = @args == 1 ? %{ $args[0] } : @args;
  
      my $module   = delete $args{'module'};
      my $cpanfile = delete $args{'cpanfile'};
  
      Carp::croak("Please provide either 'module' or 'cpanfile'")
          unless $module xor $cpanfile;
  
      if ( $module ) {
          my ( $version, $phase, $type ) = delete @args{qw< version phase type >};
          $args{'modules'} =
              Pakket::Scaffolder::Perl::Module->new(
                  'name' => $module,
                  ( version => $version )x!! defined $version,
                  ( phase   => $phase   )x!! defined $phase,
                  ( type    => $type    )x!! defined $type,
              )->prereq_specs;
      }
      else {
          $args{'modules'} =
              Pakket::Scaffolder::Perl::CPANfile->new(
                  'cpanfile' => $cpanfile
              )->prereq_specs;
      }
  
      return \%args;
  }
  
  sub run {
      my $self = shift;
      my %failed;
  
      # Bootstrap toolchain
      for my $dist ( @{ $self->perl_bootstrap_modules } ) {
          # TODO: check versions
          if ( exists $self->spec_index->{$dist} ) {
              $log->debugf( 'Skipping %s (already have version: %s)',
                            $dist, $self->spec_index->{$dist} );
              next;
          }
  
          $log->debugf( 'Bootstrapping config: %s', $dist );
          my $requirements = $self->prereqs->requirements_for(qw< configure requires >);
          eval {
              $self->create_spec_for( dist => $dist, $requirements );
              1;
          } or do {
              my $err = $@ || 'zombie error';
              Carp::croak("Cannot bootstrap toolchain distribution: $dist ($err)\n");
          };
      }
  
      # the rest
      for my $phase ( @{ $self->phases } ) {
          $log->debugf( 'Phase: %s', $phase );
          for my $type ( qw< requires recommends suggests > ) {
              next unless is_hashref( $self->modules->{ $phase }{ $type } );
  
              my $requirements = $self->prereqs->requirements_for( $phase, $type );
  
              for my $module ( sort keys %{ $self->modules->{ $phase }{ $type } } ) {
                  eval {
                      $self->create_spec_for( module => $module, $requirements );
                      1;
                  } or do {
                      my $err = $@ || 'zombie error';
                      $failed{$module} = $err;
                  };
              }
          }
      }
  
      for my $f ( keys %failed ) {
          $log->infof( "[FAILED] %s: %s", $f, $failed{$f} );
      }
  
      $log->info( 'Done' );
  }
  
  sub skip_name {
      my ( $self, $name ) = @_;
  
      if ( should_skip_module($name) ) {
          $log->debugf( "%sSkipping %s (core module, not dual-life)", $self->spaces, $name );
          return 1;
      }
  
      if ( exists $self->known_names_to_skip->{ $name } ) {
          $log->debugf( "%sSkipping %s (known 'bad' name for configuration)", $self->spaces, $name );
          return 1;
      }
  
      return 0;
  }
  
  sub unpack {
      my ( $self, $target, $file ) = @_;
  
      my $archive = Archive::Any->new($file);
  
      if ( $archive->is_naughty ) {
          die $log->critical("Suspicious module ($file)");
      }
  
      $archive->extract($target);
  
      # Determine if this is a directory in and of itself
      # or whether it's just a bunch of files
      # (This is what Archive::Any refers to as "impolite")
      # It has to be done manually, because the list of files
      # from an archive might return an empty directory listing
      # or none, which confuses us
      my @files = $target->children();
      if ( @files == 1 && $files[0]->is_dir ) {
          # Polite
          return $files[0];
      }
  
      # Is impolite, meaning it's just a bunch of files
      # (or a single file, but still)
      return $target;
  }
  
  sub create_spec_for {
      my ( $self, $type, $name, $requirements ) = @_;
      return if $self->skip_name($name);
      return if $self->processed_dists->{ $name }++;
  
      my $release = $self->get_release_info($type, $name, $requirements);
      return if exists $release->{'skip'};
  
      my $dist_name    = $release->{'distribution'};
      my $rel_version  = $release->{'version'};
  
      $log->infof( '%sWorking on %s (%s)', $self->spaces, $dist_name, $rel_version );
  
      my $package_spec = {
          'Package' => {
              'category' => 'perl',
              'name'     => $dist_name,
              'version'  => $rel_version,
              'release'  => 1, # hmm... ???
          },
      };
  
      my $package   = Pakket::Package->new_from_spec($package_spec);
      my $full_name = $package->full_name;
  
      $self->set_depth( $self->depth + 1 );
  
  
      # Source
  
      # check if we already have the source in the repo
      if ( $self->source_repo->has_object( $package->id ) ) {
          $log->debugf(
              "Package %s - source already exists in repo (skipping).",
              $full_name
          );
  
      } else {
          # Download if source doesn't exist in cache
          my $download     = 1;
          my $download_url = $self->rewrite_download_url( $release->{'download_url'} );
  
          if ( $self->_has_cache_dir ) {
              my $from_name = $download_url
                  ? $download_url =~ s{^.+/}{}r
                  : $dist_name . '-' . $rel_version . '.tar.gz';
  
              my $from_file = path( $self->cache_dir, $from_name );
  
              if ( $from_file->exists ) {
                  $log->debugf(
                      'Found source for %s [%s]',
                      $full_name, $from_file->stringify
                  );
  
                  my $target = Path::Tiny->tempdir();
                  my $dir    = $self->unpack( $target, $from_file );
  
                  $self->source_repo->store_package_source(
                      $package, $dir,
                  );
  
                  $download = 0;
              }
          }
  
          if ( $download ) {
              if ( $download_url ) {
                  my $source_file = path(
                      $self->download_dir,
                      ( $download_url =~ s{^.+/}{}r )
                  );
  
                  $self->ua->mirror( $download_url, $source_file );
  
                  my $target = Path::Tiny->tempdir();
                  my $dir    = $self->unpack( $target, $source_file );
  
                  $self->source_repo->store_package_source(
                      $package, $dir,
                  );
  
              }
              else {
                  $log->errorf( "--- can't find download_url for %s-%s", $dist_name, $rel_version );
              }
          }
      }
  
  
      # Spec
  
      if ( $self->spec_repo->retrieve_location( $full_name ) ) {
          $log->debugf(
              "Package %s - spec already exists in repo (skipping).",
              $full_name
          );
  
          return;
      }
  
      my $dep_modules = $release->{'prereqs'};
      my $dep_prereqs = CPAN::Meta::Prereqs->new( $dep_modules );
  
      # options: configure, develop, runtime, test
      for my $phase ( @{ $self->phases } ) {
          my $prereq_data = $package_spec->{'Prereqs'}{'perl'}{$phase} = +{};
  
          for my $dep_type (qw< requires recommends suggests >) {
              next unless is_hashref( $dep_modules->{ $phase }{ $dep_type } );
  
              my $dep_requirements = $dep_prereqs->requirements_for( $phase, $dep_type );
  
              for my $module ( keys %{ $dep_modules->{ $phase }{ $dep_type } } ) {
                  next if $self->skip_name($module);
  
                  my $rel = $self->get_release_info( module => $module, $dep_requirements );
                  next if exists $rel->{'skip'};
  
                  my $dist = $rel->{'distribution'};
  
                  if ( exists $self->known_incorrect_dependencies->{ $package->name }{ $dist } ) {
                      $log->debugf( "%sskipping %s (known 'bad' dependency for %s)",
                                    $self->spaces, $dist, $package->name );
                      next;
                  }
  
                  $prereq_data->{ $dist } = +{
                      'version' => ( $rel->{'write_version_as_zero'} ? "0" : $rel->{'version'} )
                  };
              }
  
              # recurse through those as well
              $self->create_spec_for( 'dist' => $_, $dep_requirements )
                  for keys %{ $package_spec->{'Prereqs'}{'perl'}{$phase} };
          }
      }
  
      # We had a partial Package object
      # So now we have to recreate that package object
      # based on the full specs (including prereqs)
      $package = Pakket::Package->new_from_spec($package_spec);
  
      my $filename = $self->spec_repo->store_package_spec($package);
  
      $self->set_depth( $self->depth - 1 );
  
      $log->infof( '%sDone: %s (%s)', $self->spaces, $dist_name, $rel_version );
  }
  
  sub get_dist_name {
      my ( $self, $module_name ) = @_;
  
      # fist check if we can get it from 02packages
      exists $self->cpan_02packages->{$module_name}
          and return $self->cpan_02packages->{$module_name}{'distribution'};
  
      # fallback to metacpan check
      $module_name = $self->known_incorrect_name_fixes->{ $module_name }
          if exists $self->known_incorrect_name_fixes->{ $module_name };
  
      my $dist_name;
  
      eval {
          my $mod_url  = $self->metacpan_api . "/module/$module_name";
          my $response = $self->ua->get($mod_url);
  
          $response->{'status'} == 200
              and Carp::croak("Cannot fetch $mod_url");
  
          my $content = decode_json $response->{'content'};
          $dist_name  = $content->{'distribution'};
  
          1;
      } or do {
          my $error = $@ || 'Zombie error';
          $log->debug($error);
      };
  
      # another check (if not found yet): check if name matches a distribution name
      if ( !$dist_name ) {
          eval {
              my $name = $module_name =~ s/::/-/rgsmx;
              my $res = $self->ua->post( $self->metacpan_api . '/release',
                  +{ 'content' => $self->get_is_dist_name_query($name) } );
  
              $res->{'status'} == 200 or Carp::croak();
              my $res_body = decode_json $res->{'content'};
              $res_body->{'hits'}{'total'} > 0 or Carp::croak();
              $dist_name = $name;
              1;
          } or do {
              my $error = $@ || 'Zombie error';
              Carp::croak("Cannot find module by name: '$module_name'");
          };
      }
  
      return $dist_name;
  }
  
  sub get_release_info {
      my ( $self, $type, $name, $requirements ) = @_;
  
      my $dist_name = $type eq 'module'
          ? $self->get_dist_name($name)
          : $name;
      return +{ 'skip' => 1 } if $self->skip_name($dist_name);
  
      my $req_as_hash = $requirements->as_string_hash;
      my $write_version_as_zero = !!(
          defined $req_as_hash->{ $name }
          and version->parse( $req_as_hash->{ $name } =~ s/[^0-9.]//gr ) == 0
      );
  
      # first try the latest
  
      my $latest = $self->get_latest_release_info( $dist_name );
      $latest->{'write_version_as_zero'} = $write_version_as_zero;
      return $latest
          if defined $latest->{'version'}
             and defined $latest->{'download_url'}
             and $requirements->accepts_module( $name => $latest->{'version'} );
  
  
      # else: fetch all release versions for this distribution
  
      my $release_prereqs;
      my $version;
      my $download_url;
  
      my %all_dist_releases;
      {
          my $res = $self->ua->post( $self->metacpan_api . "/release",
                                 +{ content => $self->get_release_query($dist_name) });
          Carp::croak("Can't find any release for $dist_name") if $res->{'status'} != 200;
          my $res_body = decode_json $res->{'content'};
  
          is_arrayref( $res_body->{'hits'}{'hits'} )
              or Carp::croak("Can't find any release for $dist_name");
  
          %all_dist_releases =
              map {
                  my $v = $_->{'fields'}{'version'};
                  ( is_arrayref($v) ? $v->[0] : $v ) => {
                      'prereqs'      => $_->{'_source'}{'metadata'}{'prereqs'},
                      'download_url' => $_->{'_source'}{'download_url'},
                  },
              }
              @{ $res_body->{'hits'}{'hits'} };
      }
  
      # get the matching version according to the spec
  
      my @valid_versions;
      for my $v ( keys %all_dist_releases ) {
          eval {
              version->parse($v);
              push @valid_versions => $v;
              1;
          } or do {
              my $err = $@ || 'zombie error';
              $log->debugf( '[VERSION ERROR] distribution: %s, version: %s, error: %s',
                            $dist_name, $v, $err );
          };
      }
  
      for my $v ( sort { version->parse($b) <=> version->parse($a) } @valid_versions ) {
          if ( $requirements->accepts_module($name => $v) ) {
              $version         = $v;
              $release_prereqs = $all_dist_releases{$v}{'prereqs'} || {};
              $download_url    =
                  $self->rewrite_download_url( $all_dist_releases{$v}{'download_url'} );
              last;
          }
      }
      $version or Carp::croak("Cannot match release for $dist_name");
  
      $version = $self->known_incorrect_version_fixes->{ $dist_name }
          if exists $self->known_incorrect_version_fixes->{ $dist_name };
  
      return +{
          'distribution'          => $dist_name,
          'version'               => $version,
          'prereqs'               => $release_prereqs,
          'download_url'          => $download_url,
          'write_version_as_zero' => $write_version_as_zero,
      };
  }
  
  sub rewrite_download_url {
      my ( $self, $download_url ) = @_;
      my $rewrite = $self->config->{'perl'}{'metacpan'}{'rewrite_download_url'};
      return $download_url unless is_hashref($rewrite);
      my ( $from, $to ) = @{$rewrite}{qw< from to >};
      return ( $download_url =~ s/$from/$to/r );
  }
  
  sub get_latest_release_info {
      my ( $self, $dist_name ) = @_;
  
      my $res = $self->ua->get( $self->metacpan_api . "/release/$dist_name" );
      return unless $res->{'status'} == 200; # falling back to check all
  
      my $res_body= decode_json $res->{'content'};
  
      return +{
          'distribution' => $dist_name,
          'version'      => $res_body->{'version'},
          'download_url' => $res_body->{'download_url'},
          'prereqs'      => $res_body->{'metadata'}{'prereqs'},
      };
  }
  
  sub get_is_dist_name_query {
      my ( $self, $name ) = @_;
  
      return encode_json(
          {
              'query'  => {
                  'bool' => {
                      'must' => [
                          { 'term'  => { 'distribution' => $name } },
                      ]
                  }
              },
              'fields' => [qw< distribution >],
              'size'   => 0,
          }
      );
  }
  
  sub get_release_query {
      my ( $self, $dist_name ) = @_;
  
      return encode_json(
          {
              'query'  => {
                  'bool' => {
                      'must' => [
                          { 'term'  => { 'distribution' => $dist_name } },
                          # { 'terms' => { 'status' => [qw< cpan latest >] } }
                      ]
                  }
              },
              'fields'  => [qw< version >],
              '_source' => [qw< metadata.prereqs download_url >],
              'size'    => 999,
          }
      );
  }
  
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  1;
  __END__
PAKKET_SCAFFOLDER_PERL

$fatpacked{"Pakket/Scaffolder/Perl/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_PERL_CPANFILE';
  package Pakket::Scaffolder::Perl::CPANfile;
  # ABSTRACT: Scffolding Perl cpanfile reader
  
  use Moose;
  use MooseX::StrictConstructor;
  use Module::CPANfile;
  
  has 'cpanfile' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'prereq_specs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_prereq_specs',
  );
  
  sub _build_prereq_specs {
      my $self = shift;
      my $file = Module::CPANfile->load( $self->cpanfile );
      return $file->prereq_specs;
  }
  
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  1;
  __END__
PAKKET_SCAFFOLDER_PERL_CPANFILE

$fatpacked{"Pakket/Scaffolder/Perl/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_PERL_MODULE';
  package Pakket::Scaffolder::Perl::Module;
  # ABSTRACT: scaffolder: module config representation
  
  use Moose;
  use MooseX::StrictConstructor;
  
  has 'name' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => sub {1},
  );
  
  has 'version' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {0},
  );
  
  has 'phase' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {'runtime'},
  );
  
  has 'type' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {'requires'},
  );
  
  sub BUILDARGS {
      my ( $class, @args ) = @_;
      my %args = @args == 1 ? %{ $args[0] } : @args;
  
      if ( $args{'name'} =~ /^ (.+) \@ (.+) $/x ) {
          $args{'name'}    = $1;
          $args{'version'} = "== $2";
      }
      elsif ( $args{'name'} =~ /^ (.+) \~ (.+) $/x ) {
          $args{'name'}    = $1;
          $args{'version'} = $2;
      }
  
      return \%args;
  }
  
  sub prereq_specs {
      my $self = shift;
      return +{
          $self->phase => +{
              $self->type => +{
                  $self->name => $self->version,
              },
          },
      };
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  1;
  __END__
PAKKET_SCAFFOLDER_PERL_MODULE

$fatpacked{"Pakket/Scaffolder/Perl/Role/Borked.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_PERL_ROLE_BORKED';
  package Pakket::Scaffolder::Perl::Role::Borked;
  # ABSTRACT: scaffolder: perl: known issues
  
  use Moose::Role;
  
  has 'known_incorrect_name_fixes' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          +{
              'App::Fatpacker'            => 'App::FatPacker',
              'Test::YAML::Meta::Version' => 'Test::YAML::Meta', # not sure about this
              'Net::Server::SS::Prefork'  => 'Net::Server::SS::PreFork',
          }
      },
  );
  
  has 'known_incorrect_version_fixes' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          +{
              'ExtUtils-Constant' => '0.23',
              'IO-Capture'        => '0.05',
          }
      },
  );
  
  has 'known_incorrect_dependencies' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          +{
              'Module-Install' => {
                  'libwww-perl' => 1,
                  'PAR-Dist'    => 1,
              },
              'libwww-perl'    => {
                  'NTLM' => 1,
              },
          }
      },
  );
  
  has 'known_names_to_skip' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          +{
              'perl'                    => 1,
              'tinyperl'                => 1,
              'perl_mlb'                => 1,
              'HTTP::GHTTP'             => 1,
              'Text::MultiMarkdown::XS' => 1, # ADOPTME
              'URI::file'               => 1, # in URI, appears with weird version
              'URI::Escape'             => 1, # in URI, appears with weird version
          }
      },
  );
  
  no Moose::Role;
  1;
  __END__
PAKKET_SCAFFOLDER_PERL_ROLE_BORKED

$fatpacked{"Pakket/Scaffolder/Role/Backend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_ROLE_BACKEND';
  package Pakket::Scaffolder::Role::Backend;
  # ABSTRACT: scaffolder: role for backend
  
  use Moose::Role;
  
  use HTTP::Tiny;
  
  requires 'run';
  
  has extract => (
      is      => 'ro',
      isa     => 'Bool',
      default => 0,
  );
  
  has ua => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_ua',
  );
  
  sub _build_ua {
      return HTTP::Tiny->new();
  }
  
  no Moose::Role;
  1;
  __END__
PAKKET_SCAFFOLDER_ROLE_BACKEND

$fatpacked{"Pakket/Scaffolder/Role/Terminal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_ROLE_TERMINAL';
  package Pakket::Scaffolder::Role::Terminal;
  # ABSTRACT: scaffolder: role for output handling
  
  use Moose::Role;
  
  has depth => (
      is      => 'ro',
      isa     => 'Num',
      default => 0,
      writer  => 'set_depth',
  );
  
  sub spaces {
      my $self = shift;
      return ' 'x( $self->depth * 2 );
  }
  
  
  no Moose::Role;
  1;
  __END__
PAKKET_SCAFFOLDER_ROLE_TERMINAL

$fatpacked{"Pakket/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SERVER';
  package Pakket::Server;
  # ABSTRACT: Start a Pakket server
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Log::Any qw< $log >;
  use Plack::Runner;
  
  use Pakket::Server::App;
  
  has 'port' => (
      'is'        => 'ro',
      'isa'       => 'Int',
      'predicate' => 'has_port',
  );
  
  sub run {
      my $self = shift;
  
      Pakket::Server::App->setup();
      my $app    = Pakket::Server::App->to_app;
      my $runner = Plack::Runner->new();
  
      my @runner_opts = (
          $self->has_port ? ( '--port', $self->port ) : (),
      );
  
      $runner->parse_options(@runner_opts);
      return $runner->run($app);
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
PAKKET_SERVER

$fatpacked{"Pakket/Server/App.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SERVER_APP';
  package Pakket::Server::App;
  # ABSTRACT: Webapp endpoints to server Pakket information
  
  use Dancer2;
  use Dancer2::Plugin::Pakket::ParamTypes;
  
  use Log::Any qw< $log >;
  use Pakket::Config;
  use Pakket::Repository::Spec;
  use Pakket::Repository::Parcel;
  use Pakket::Repository::Source;
  
  ## no critic qw(Modules::RequireExplicitInclusion)
  
  sub setup {
      my $class = shift;
      my $config_reader = Pakket::Config->new();
      my %config        = (
          %{ $config_reader->read_config },
          %{ config() },
      );
  
      my %instance_map = (
          'spec'   => sub { return Pakket::Repository::Spec->new(@_);   },
          'source' => sub { return Pakket::Repository::Source->new(@_); },
          'parcel' => sub { return Pakket::Repository::Parcel->new(@_); },
      );
  
      my $repositories_data = $config{'repositories'};
      foreach my $repository_type ( keys %{$repositories_data} ) {
          my $repo = $instance_map{$repository_type}->(
              'backend' => $repositories_data->{$repository_type},
          );
  
          prefix "/$repository_type" => sub {
              get '/has_object' => with_types [
                  [ 'query', 'id', 'Str', 'MissingID' ],
              ] => sub {
                  my $id = query_parameters->get('id');
  
                  return encode_json({
                      'has_object' => $repo->has_object($id),
                  });
              };
  
              get '/all_object_ids' => sub {
                  return encode_json({
                      'object_ids' => $repo->all_object_ids,
                  });
              };
  
              prefix '/retrieve' => sub {
                  get '/content' => with_types [
                      [ 'query', 'id', 'Str', 'MissingID' ],
                  ] => sub {
                      my $id = query_parameters->get('id');
  
                      return encode_json( {
                          'id'      => $id,
                          'content' => $repo->retrieve_content($id),
                      } );
                  };
  
                  get '/location' => with_types [
                      [ 'query', 'id', 'Str', 'MissingID' ],
                  ] => sub {
                      my $id   = query_parameters->get('id');
                      my $file = $repo->retrieve_location($id);
  
                      # This is already anchored to the repo
                      # (And no user input can change the path it will reach)
                      send_file( $file, 'system_path' => 1 );
                  };
              };
  
              prefix '/store' => sub {
                  # There is no body to check, because the body is JSON content
                  # So we manually decode and check
                  post '/content' => sub {
                      my $data    = decode_json( request->body );
                      my $id      = $data->{'id'};
                      my $content = $data->{'content'};
  
                      defined && length
                          or send_error( 'Bad input', 400 )
                          for $id, $content;
  
                      $repo->store_content( $id, $content );
                      return encode_json( { 'success' => 1 } );
                  };
  
                  post '/location' => with_types [
                      [ 'query', 'id', 'Str',  'MissingID' ],
                  ] => sub {
                      my $id   = query_parameters->get('id');
                      my $file = Path::Tiny->tempfile;
                      $file->spew_raw( request->body );
                      $repo->store_location( $id, $file );
                      return encode_json( { 'success' => 1 } );
                  };
              };
  
              prefix '/remove' => sub {
                  get '/location' => with_types [
                      [ 'query', 'id', 'Str',  'MissingID' ],
                  ] => sub {
                      my $id = query_parameters->get('id');
                      $repo->remove_location( $id );
                      return encode_json( { 'success' => 1 } );
                  };
  
                  get '/content' => with_types [
                      [ 'query', 'id', 'Str',  'MissingID' ],
                  ] => sub {
                      my $id = query_parameters->get('id');
                      $repo->remove_content( $id );
                      return encode_json( { 'success' => 1 } );
                  };
              };
          };
      }
  }
  
  1;
  
  __END__
PAKKET_SERVER_APP

$fatpacked{"Pakket/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_TYPES';
  package Pakket::Types;
  # ABSTRACT: Type definitions for Pakket
  
  use strict;
  use warnings;
  
  use Moose::Util::TypeConstraints;
  use Carp     qw< croak >;
  use Log::Any qw< $log >;
  use Safe::Isa;
  use Module::Runtime qw< require_module >;
  use Pakket::Constants qw<
      PAKKET_LATEST_VERSION
      PAKKET_DEFAULT_RELEASE
      PAKKET_VALID_PHASES
  >;
  
  # PakketRepositoryBackend
  
  sub _coerce_backend_from_arrayref {
      my $backend_data = shift;
      my ( $subclass, @args ) = @{$backend_data};
      my $class = "Pakket::Repository::Backend::$subclass";
  
      eval { require_module($class); 1; } or do {
          die $log->critical("Failed to load backend '$class': $@");
      };
  
      return $class->new(@args);
  }
  
  subtype 'PakketRepositoryBackend', as 'Object', where {
      $_->$_isa('ARRAY') || $_->$_does('Pakket::Role::Repository::Backend')
  }, message {
      'Must be a Pakket::Repository::Backend object or an arrayref'
  };
  
  coerce 'PakketRepositoryBackend', from 'ArrayRef',
      via { return _coerce_backend_from_arrayref($_); };
  
  # PakketVersion
  
  subtype 'PakketVersion', as 'Str';
  
  coerce 'PakketVersion', from 'Undef',
      via { return PAKKET_LATEST_VERSION() };
  
  # PakketRelease
  
  subtype 'PakketRelease', as 'Int';
  
  coerce 'PakketRelease', from 'Undef',
      via { return PAKKET_DEFAULT_RELEASE() };
  
  # PakketVersioning
  
  subtype 'PakketVersioning', as 'Object',
  where { $_->$_does('Pakket::Role::Versioning') };
  
  coerce 'PakketVersioning', from 'Str',
  via {
      my $type  = $_;
      my $class = "Pakket::Versioning::$type";
  
      eval {
          require_module($class);
          1;
      } or do {
          my $error = $@ || 'Zombie error';
          croak( $log->critical("Could not load versioning module ($type)") );
      };
  
      return $class->new();
  };
  
  # PakketPhase
  
  enum 'PakketPhase' => [ keys %{PAKKET_VALID_PHASES()} ];
  
  no Moose::Util::TypeConstraints;
  
  1;
  
  __END__
  
  =pod
PAKKET_TYPES

$fatpacked{"Pakket/Uninstaller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_UNINSTALLER';
  package Pakket::Uninstaller;
  
  # ABSTRACT: Uninstall pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use Path::Tiny qw< path  >;
  use Types::Path::Tiny qw< Path  >;
  use Log::Any qw< $log >;
  
  use Pakket::Log qw< log_success log_fail >;
  use Pakket::LibDir;
  use Pakket::InfoFile;
  
  has 'lib_dir' => (
      'is'       => 'ro',
      'isa'      => Path,
      'coerce'   => 1,
      'required' => 1,
  );
  
  has 'packages' => (
      'is'       => 'ro',
      'isa'      => 'ArrayRef',
      'required' => 1,
  );
  
  has 'without_dependencies' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => 0,
  );
  
  sub get_list_of_packages_for_uninstall {
      my $self = shift;
  
      if ( !@{ $self->packages } ) {
          die $log->critical('Did not receive any packages to uninstall');
      }
  
      my $active_dir = Pakket::LibDir::get_active_dir( $self->lib_dir );
      my $info_file  = Pakket::InfoFile::load_info_file($active_dir);
      my @packages_for_uninstall
          = $self->get_packages_available_for_uninstall($info_file);
  
      return @packages_for_uninstall;
  }
  
  sub uninstall {
      my $self = shift;
  
      my $active_dir = Pakket::LibDir::get_active_dir( $self->lib_dir );
      my $info_file  = Pakket::InfoFile::load_info_file($active_dir);
      my @packages_for_uninstall
          = $self->get_packages_available_for_uninstall($info_file);
      unless ( 0 + @packages_for_uninstall ) {
          $log->notice("Don't have any packages for uninstall");
          return;
      }
  
      my $work_dir = Pakket::LibDir::create_new_work_dir( $self->lib_dir );
  
      foreach my $package (@packages_for_uninstall) {
          $self->delete_package( $work_dir, $info_file, $package );
      }
  
      Pakket::InfoFile::save_info_file( $work_dir, $info_file );
      Pakket::LibDir::activate_work_dir($work_dir);
  
      $log->infof(
          "Finished uninstalling %d packages from %s",
          0 + @packages_for_uninstall,
          $self->lib_dir
      );
  
      log_success(
          "Finished uninstalling:\n"
              . join( "\n",
              map { $_->{category} . "/" . $_->{name} }
                  @packages_for_uninstall )
      );
  
      Pakket::LibDir::remove_old_libraries( $self->lib_dir );
  
      return;
  }
  
  sub get_packages_available_for_uninstall {
      my ( $self, $info_file ) = @_;
  
      # Algorithm
      # Walk through requested packages and their dependency tree and mark them 'to_delete'
      # Walk through all installed packages without 'to_delete' and their dependencies and mark them 'keep_it'
      # Remove all packages which have 'to_delete' and missing 'keep_it'
      #
      # Special case: throw an error if user explicitly wants to remove packages ('delete_by_requirements'),
      # but that packages is required by any packages from the list 'keep_it.
  
      #mark packages for uninstall as 'to_delete' and 'to_delete_by_requerement'
      my $installed_packages = $info_file->{'installed_packages'};
      my @queue;
      my ( %to_delete, %to_delete_by_requirements );
      foreach my $package ( @{ $self->packages } ) {
          if ( !$installed_packages->{ $package->{category} }
              { $package->{name} } )
          {
              die $log->critical(
                  "Package $package->{category}/$package->{name} doesn't exists"
              );
          }
          $to_delete{ $package->{category} }{ $package->{name} }++ and next;
          push @queue, $package;
          $to_delete_by_requirements{ $package->{category} }
              { $package->{name} }++;
      }
  
      # walk through dependencies and mark them as 'to delete'
      if ( !$self->without_dependencies ) {
          while ( 0 + @queue ) {
              my $package  = shift @queue;
              my $prereqs = $installed_packages->{ $package->{category} }
                  { $package->{name} }{'prereqs'};
              for my $category ( keys %$prereqs ) {
                  for my $type ( keys %{ $prereqs->{$category} } ) {
                      for my $name ( keys %{ $prereqs->{$category}{$type} } ) {
                          $to_delete{$category}{$name}++ and next;
                          push @queue,
                              { 'category' => $category, 'name' => $name };
                      }
                  }
              }
          }
      }
  
      #select all package without 'to_delete' and mark them and theirs dependencies as 'keep_it'
      my %keep_it;
      foreach my $category ( keys %$installed_packages ) {
          foreach my $name ( keys %{ $installed_packages->{$category} } ) {
              $to_delete{$category}{$name} and next;
              $keep_it{$category}{$name}++ and next;
  
              # walk through dependencies
              @queue = ( { category => $category, name => $name } );
              while ( 0 + @queue ) {
                  my $package  = shift @queue;
                  my $prereqs = $installed_packages->{ $package->{category} }
                      { $package->{name} }{'prereqs'};
                  for my $category ( keys %$prereqs ) {
                      for my $type ( keys %{ $prereqs->{$category} } ) {
                          for my $name (
                              keys %{ $prereqs->{$category}{$type} } )
                          {
                              $keep_it{$category}{$name}++ and next;
                              $to_delete_by_requirements{$category}{$name}
                                  and die $log->critical(
                                  "Can't uninstall package $category/$name, it's requered by $package->{category}/$package->{name}"
                                  );
                              push @queue,
                                  { 'category' => $category, 'name' => $name };
                              delete $to_delete{$category}{$name};
                          }
                      }
                  }
              }
          }
      }
  
      my @packages_for_uninstall;
      for my $category ( keys %to_delete ) {
          for my $name ( keys %{ $to_delete{$category} } ) {
              push @packages_for_uninstall,
                  { 'category' => $category, 'name' => $name };
          }
      }
      return @packages_for_uninstall;
  }
  
  sub delete_package {
      my ( $self, $work_dir, $info_file, $package ) = @_;
      my $info = delete $info_file->{installed_packages}{ $package->{category} }
          { $package->{name} };
      $log->debugf( "Deleting package %s/%s",
          $package->{category}, $package->{name} );
  
      for my $file ( @{ $info->{files} } ) {
          delete $info_file->{installed_files}{$file};
          my ( $type, $file_name ) = $file =~ /(\w+)\/(.+)/;
          my $path = $work_dir->child($file_name);
          $log->debugf( "Deleting file %s", $path );
          if ( !$path->remove ) {
              $log->error("Could not remove $path: $!");
          }
  
          # remove parent dirs while there are no children
          my $parent = $path->parent;
          while ( !( 0 + $parent->children ) ) {
              $log->debugf( "Deleting directory %s", $parent );
              rmdir $parent;
              $parent = $parent->parent;
          }
  
      }
      return;
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
PAKKET_UNINSTALLER

$fatpacked{"Pakket/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_UTILS';
  package Pakket::Utils;
  # ABSTRACT: Utilities for Pakket
  
  use strict;
  use warnings;
  use version 0.77;
  
  use Exporter qw< import >;
  use JSON::MaybeXS;
  
  our @EXPORT_OK = qw<
      is_writeable
      generate_env_vars
      canonical_package_name
      encode_json_canonical
      encode_json_pretty
  >;
  
  sub is_writeable {
      my $path = shift; # Path::Tiny objects
  
      while ( !$path->is_rootdir ) {
          $path->exists and return -w $path;
          $path = $path->parent;
      }
  
      return -w $path;
  }
  
  sub generate_env_vars {
      my ( $build_dir, $prefix ) = @_;
      my $lib_path = generate_lib_path($prefix);
      my $bin_path = generate_bin_path($prefix);
  
      my @perl5lib = (
          $build_dir,
          $prefix->child( qw<lib perl5> )->absolute->stringify,
      );
  
      my %perl_opts = (
          'PERL5LIB'                  => join( ':', @perl5lib ),
          'PERL_LOCAL_LIB_ROOT'       => '',
          'PERL5_CPAN_IS_RUNNING'     => 1,
          'PERL5_CPANM_IS_RUNNING'    => 1,
          'PERL5_CPANPLUS_IS_RUNNING' => 1,
          'PERL_MM_USE_DEFAULT'       => 1,
          'PERL_MB_OPT'               => '',
          'PERL_MM_OPT'               => '',
      );
  
      return (
          'CPATH'           => $prefix->child('include')->stringify,
          'LD_LIBRARY_PATH' => $lib_path,
          'LIBRARY_PATH'    => $lib_path,
          'PATH'            => $bin_path,
          %perl_opts,
      );
  }
  
  sub generate_lib_path {
      my $prefix = shift;
  
      my $lib_path = $prefix->child('lib')->absolute->stringify;
      if ( defined( my $env_library_path = $ENV{'LD_LIBRARY_PATH'} ) ) {
          $lib_path .= ":$env_library_path";
      }
  
      return $lib_path;
  }
  
  sub generate_bin_path {
      my $prefix = shift;
  
      my $bin_path = $prefix->child('bin')->absolute->stringify;
      if ( defined( my $env_bin_path = $ENV{'PATH'} ) ) {
          $bin_path .= ":$env_bin_path";
      }
  
      return $bin_path;
  }
  
  sub canonical_package_name {
      my ( $category, $package, $version, $release ) = @_;
  
      if ( $version && $release ) {
          return sprintf '%s/%s=%s:%s', $category, $package, $version, $release;
      }
  
      if ($version) {
          return sprintf '%s/%s=%s', $category, $package, $version;
      }
  
      return sprintf '%s/%s', $category, $package;
  }
  
  sub encode_json_canonical {
      my $content = shift;
      return JSON::MaybeXS->new->canonical->encode($content);
  }
  
  sub encode_json_pretty {
      my $content = shift;
      return JSON::MaybeXS->new->pretty->canonical->encode($content);
  }
  
  1;
  
  __END__
PAKKET_UTILS

$fatpacked{"Pakket/Utils/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_UTILS_PERL';
  package Pakket::Utils::Perl;
  # ABSTRACT: Perl specific utilities for Pakket
  
  use strict;
  use warnings;
  use version 0.77;
  use Exporter   qw< import >;
  use Path::Tiny qw< path   >;
  use Module::CoreList;
  
  our @EXPORT_OK = qw< list_core_modules should_skip_module >;
  
  sub list_core_modules {
      ## no critic qw(Variables::ProhibitPackageVars)
      return \%Module::CoreList::upstream;
  }
  
  sub should_skip_module {
      my $name = shift;
  
      if ( Module::CoreList::is_core($name) and !${Module::CoreList::upstream}{$name} ) {
          return 1;
      }
  
      return 0;
  }
  
  1;
PAKKET_UTILS_PERL

$fatpacked{"Pakket/Utils/Repository.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_UTILS_REPOSITORY';
  package Pakket::Utils::Repository;
  
  use strict;
  use warnings;
  
  use Path::Tiny qw< path >;
  use parent 'Exporter';
  
  our @EXPORT_OK = (qw< gen_repo_config >);
  
  my %file_ext = (
      'spec'   => 'ini',
      'source' => 'spkt',
      'parcel' => 'pkt',
  );
  
  sub gen_repo_config {
      my ( $self, $type, $directory ) = @_;
      $directory or return;
  
      if ( $directory =~ m{^/} ) {
          my $path = path($directory);
          $path->exists && $path->is_dir
              or die "Bad directory for $type repo: $path\n";
  
          return [
              'File',
              'directory'      => $directory,
              'file_extension' => $file_ext{$type},
          ];
  
      } elsif ( $directory =~ m{^(https?)://([^/:]+):?([^/]+)?(/.*)?$} ) {
          my ( $protocol, $host, $port, $base_path ) = ( $1, $2, $3, $4 );
          $port or $port = $protocol eq 'http' ? 80 : 443;
  
          return [
              'HTTP',
              'host'      => $host,
              'port'      => $port,
              'base_path' => $base_path,
          ];
      }
  
      return;
  }
  
  1;
  __END__
PAKKET_UTILS_REPOSITORY

$fatpacked{"Pakket/Versioning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_VERSIONING';
  package Pakket::Versioning;
  # ABSTRACT: A versioning class
  
  use Moose;
  use MooseX::StrictConstructor;
  use Carp            qw< croak >;
  use Log::Any        qw< $log >;
  use Module::Runtime qw< require_module >;
  
  has 'type' => (
      'is'       => 'ro',
      'isa'      => 'PakketVersioning',
      'coerce'   => 1,
      'required' => 1,
      'handles'  => [ 'compare' ],
  );
  
  sub parse_req_string {
      my ( $self, $req_string ) = @_;
  
      # A filter string is a comma-separated list of conditions
      # A condition is of the form "OP VER"
      # OP is >=, <=, !=, ==, >, <
      # VER is a version string valid for the version module
      # Whitespace is ignored
      my @conditions = split /,/xms, $req_string;
      my @filters;
      foreach my $condition (@conditions) {
          if ( $condition !~ /^\s*(>=|<=|==|!=|>|<)\s*(\S*)\s*$/xms ) {
              $condition = ">= $condition";
          }
  
          my @filter = $condition =~ /^\s*(>=|<=|==|!=|>|<)\s*(\S*)\s*$/xms;
          push @filters, \@filter;
      }
  
      return \@filters;
  }
  
  my %op_map = (
      '>=' => sub { $_[0] >= 0 },
      '<=' => sub { $_[0] <= 0 },
      '==' => sub { $_[0] == 0 },
      '!=' => sub { $_[0] != 0 },
      '>'  => sub { $_[0] >  0 },
      '<'  => sub { $_[0] <  0 },
  );
  
  sub filter_version {
      my ( $self, $req_string, $versions ) = @_;
  
      foreach my $filter ( @{ $self->parse_req_string($req_string) } ) {
          my ( $op, $req_version ) = @{$filter};
  
          @{$versions}
              = grep +( $op_map{$op}->( $self->compare( $_, $req_version ) ) ),
              @{$versions};
      }
  
      return;
  }
  
  sub latest {
      my ( $self, $req_string, @versions ) = @_;
  
      # Filter all @versions based on $req_string
      $self->filter_version( $req_string, \@versions );
  
      @versions
          or croak( $log->critical('No versions provided') );
  
      # latest_version
      my $latest;
      foreach my $version (@versions) {
          if ( !defined $latest ) {
              $latest = $version;
              next;
          }
  
          if ( $self->compare( $latest, $version ) < 0 ) {
              $latest = $version;
          }
      }
  
      return $latest;
  }
  
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_VERSIONING

$fatpacked{"Pakket/Versioning/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_VERSIONING_PERL';
  package Pakket::Versioning::Perl;
  # ABSTRACT: A Perl-style versioning class
  
  use Moose;
  use MooseX::StrictConstructor;
  use version 0.77;
  
  with qw< Pakket::Role::Versioning >;
  
  sub compare {
      return version->parse( $_[1] ) <=> version->parse( $_[2] );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_VERSIONING_PERL

$fatpacked{"perl/5.22.1/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_CWD';
  package Cwd;
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
        require XSLoader;
        XSLoader::load( __PACKAGE__, $xs_version);
      } else {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        __PACKAGE__->bootstrap( $xs_version );
      }
    };
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      return $ENV{'PWD'} = EPOC::getcwd();
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
PERL_5.22.1_CWD

$fatpacked{"perl/5.22.1/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin',
  	      amigaos => 'AmigaOS');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PERL_5.22.1_FILE_SPEC

$fatpacked{"perl/5.22.1/File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::AmigaOS - File::Spec for AmigaOS
  
  =head1 SYNOPSIS
  
   require File::Spec::AmigaOS; # Done automatically by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item tmpdir
  
  Returns $ENV{TMPDIR} or if that is unset, "/t".
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
  }
  
  =item file_name_is_absolute
  
  Returns true if there's a colon in the file name,
  or if it begins with a slash.
  
  =cut
  
  sub file_name_is_absolute {
    my ($self, $file) = @_;
  
    # Not 100% robust as a "/" must not preceded a ":"
    # but this cannot happen in a well formed path.
    return $file =~ m{^/|:}s;
  }
  
  =back
  
  All the other methods are from L<File::Spec::Unix>.
  
  =cut
  
  1;
PERL_5.22.1_FILE_SPEC_AMIGAOS

$fatpacked{"perl/5.22.1/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir(
          $_[0]->_tmpdir(
              $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
          ),
          qw 'TMPDIR TMP TEMP'
      );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
PERL_5.22.1_FILE_SPEC_CYGWIN

$fatpacked{"perl/5.22.1/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there.  This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still a work in progress. ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path.  On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
PERL_5.22.1_FILE_SPEC_EPOC

$fatpacked{"perl/5.22.1/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  require File::Spec::Unix;
  my %udeps = (
      canonpath => [],
      catdir => [qw(canonpath)],
      catfile => [qw(canonpath catdir)],
      case_tolerant => [],
      curdir => [],
      devnull => [],
      rootdir => [],
      updir => [],
  );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
  	    !(grep {
  		File::Spec->can($_) != File::Spec::Unix->can($_)
  	    } @{$udeps{$meth}}) &&
  	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
  	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
      } else {
  	*{$meth} = sub {&$sub('File::Spec', @_)};
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
PERL_5.22.1_FILE_SPEC_FUNCTIONS

$fatpacked{"perl/5.22.1/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
PERL_5.22.1_FILE_SPEC_MAC

$fatpacked{"perl/5.22.1/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
      return $cached if defined $cached;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $_[0]->_cache_tmpdir(
  	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
      );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PERL_5.22.1_FILE_SPEC_OS2

$fatpacked{"perl/5.22.1/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  #dont try to load XSLoader and DynaLoader only to ultimately fail on miniperl
  if(!defined &canonpath && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
  	require XSLoader;
  	XSLoader::load("Cwd", $xs_version);
      } else {
  	require Cwd;
      }
    };
  }
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub _pp_canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  *canonpath = \&_pp_canonpath unless defined &canonpath;
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub _pp_catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  *catdir = \&_pp_catdir unless defined &catdir;
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub _pp_catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  *catfile = \&_pp_catfile unless defined &catfile;
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  use constant _fn_curdir => ".";
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  use constant _fn_devnull => "/dev/null";
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  use constant _fn_rootdir => "/";
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my ($tmpdir, %tmpenv);
  # Cache and return the calculated tmpdir, recording which env vars
  # determined it.
  sub _cache_tmpdir {
      @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
      return $tmpdir = $_[1];
  }
  # Retrieve the cached tmpdir, checking first whether relevant env vars have
  # changed and invalidated the cache.
  sub _cached_tmpdir {
      shift;
      local $^W;
      return if grep $ENV{$_} ne $tmpenv{$_}, @_;
      return $tmpdir;
  }
  sub _tmpdir {
      my $self = shift;
      my @dirlist = @_;
      my $taint = do { no strict 'refs'; ${"\cTAINT"} };
      if ($taint) { # Check for taint mode on perl >= 5.8.0
  	require Scalar::Util;
  	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
      }
      elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	@dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;
      }
      
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      if ( !$self->file_name_is_absolute($tmpdir) ) {
          # See [perl #120593] for the full details
          # If possible, return a full path, rather than '.' or 'lib', but
          # jump through some hoops to avoid returning a tainted value.
          ($tmpdir) = grep {
              $taint     ? ! Scalar::Util::tainted($_) :
              $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
          } $self->rel2abs($tmpdir), $tmpdir;
      }
      return $tmpdir;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  use constant _fn_updir => "..";
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  use constant _fn_case_tolerant => 0;
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath($self->_cwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
PERL_5.22.1_FILE_SPEC_UNIX

$fatpacked{"perl/5.22.1/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicitly requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = unixify($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $xfile : vmsify($xfile);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  sub tmpdir {
      my $self = shift @_;
      my $tmpdir = $self->_cached_tmpdir('TMPDIR');
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
      }
      else {
          $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
      }
      $self->_cache_tmpdir($tmpdir, 'TMPDIR');
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
  }
  
  =item splitpath (override)
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
          if ((grep m{/}, @_) && !(grep m{(?<!\^)[\[<:]}, @_));
  
      my($path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      # If there is no device or directory syntax on $base, make sure it
      # is treated as a directory.
      $base = VMS::Filespec::vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
PERL_5.22.1_FILE_SPEC_VMS

$fatpacked{"perl/5.22.1/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_5.22.1_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.62';
  $VERSION =~ tr/_//d;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
      $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
PERL_5.22.1_FILE_SPEC_WIN32

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


# XXX
# This script needs to be fatpacked when done.
# In order to do this, please use the pre-commit hook
# available in the tools/git-hooks directory, as such:
# ( cd .git/hooks && ln -s ../../tools/git-hooks/pre-commit )
# XXX

use strict;
use warnings;
use constant {
    'DEFAULT_PERL_VERSION' => '5.22.2',
};

use English    '-no_match_vars';
use Path::Tiny qw<path tempdir>;
use Getopt::Long qw<:config no_ignore_case>;
use App::Seacan;
use IPC::Open3 qw<open3>;

sub print_help {
    my $error   = shift;
    my $min_ver = DEFAULT_PERL_VERSION();

    $error and print "[ERROR] $error\n\n";

    print << "_END_HELP";
$PROGRAM_NAME [--perl PERL_VER] --app-dir DIR

Options:

--perl        Perl version (default: $min_ver)
--app-dir     Application directory (default: .)
--files       Additional files for inclusion
              (Specify multiple times for each file)

_END_HELP

    exit 2;
}

my $app_dir = path('.');
Getopt::Long::GetOptions(
    'perl=s'    => \( my $perl_version = DEFAULT_PERL_VERSION() ),
    'app-dir=s' => \$app_dir,
    'files=s@'  => \my @additional_files,
    'help'      => \my $help,
);

$help and print_help();

-d $app_dir or print_help('--app-dir must point to a directory');

my $cores = 1;
if ( $OSNAME =~ /linux/xms ) {
    local $SIG{'CHLD'} = 'IGNORE';
    my ( $writer, $reader, $err );
    open3( $writer, $reader, $err, 'nproc' );
    chomp( $cores = <$reader> );
}

if ( $cores > 1 ) {
    $cores -= 1;
}

my @directories  = qw<bin lib>;
my $top_src_dir  = tempdir( 'CLEANUP' => 1 );
my $top_dest_dir = tempdir( 'CLEANUP' => 1 );
my $dest_dir     = $top_dest_dir->child('pakket');
my $source_dir   = $top_src_dir->child('pakket');

$dest_dir->mkpath();
$source_dir->mkpath();

foreach my $dir (@directories) {
    path($dir)->visit(
        sub {
            my $next = shift;

            $next->is_file
                or return;

            my $next_dir  = $next->parent;
            my $next_path = $source_dir->child($next_dir);
            $next_path->mkpath();

            $next->copy($next_path);
        },
        { 'recurse' => 1 },
    );
}

# cpanfile must be there so "cpanm" would work on the app
foreach my $node ( @additional_files, 'cpanfile' ) {
    my $file = path($node);
    $file->copy( $source_dir->child($file) );
}

my $seacan = App::Seacan->new(
    'config' => {

        'seacan' => {
            'app_name' => 'pakket',
            'output'   => $dest_dir,
            'app'      => $source_dir,
        },

        'perl' => {
            'version'             => $perl_version,
                'installed_as'    => 'seacan',
                'notest'          => 1,
                'noman'           => 1,
                'relocatable_INC' => 1,
                'parallel'        => $cores,
        },
    },
);

$seacan->run;

print "Finished!\n";
system( 'tar', '--create', '--gzip', '--exclude-vcs', "--directory=$top_dest_dir",
    '--file=' . path('pakket.tar.gz')->absolute, '.', );
