#!/usr/bin/perl
use strict;
use warnings;

use Config;
use Getopt::Long          qw<:config no_ignore_case>;
use File::Path            qw<make_path remove_tree>;
use Path::Tiny            qw<path>;
use File::Copy::Recursive qw<dircopy>;
use File::Basename        qw<basename>;
use TOML::Parser;
use DDP;

# TODO:
# - replace "program" and "program name" with "package" and "package name"
# - move all hardcoded values (confs) to constants
# - rewrite in App::Cmd?

my $LOG;
sub help {
    print << "_END_HELP";
$0 [OPTIONS] ACTION PACKAGE

Actions:
    --build             build a dependency package

Options:

    -h | --help         print this screen and exit
    -v | --verbose      provide extensive output
                        (can be repeated for increased output)
         --for          build for specific Perl version
                        (current not supported)
         --build-dir    reuse an existing build directory
         --source-dir   sources directory
         --config-dir   configuration directory
_END_HELP

    exit 0;
}

sub getopt {
    my    @args = @_;
    local @ARGV = @args;

    GetOptions(
        \my %opts,
        'help|h',
        'verbose|v+',
        'for=s',
        'build=s',
        'build-dir=s',
        'source-dir=s',
        'config-dir=s',
    );

    $opts{'help'}
        and help();

    $opts{'build'}
        or die "Error: must provide an action\n";

    # rename "build" to "program" because that's clearer from our
    # perspective
    $opts{'program'} = delete $opts{'build'};

    $opts{'source-base'} = ( delete $opts{'source-dir'} || '.' );
    $opts{'config-base'} = ( delete $opts{'config-dir'} || '.' );

    $LOG = $opts{'verbose'};

    return \%opts;
}

sub LOG { $LOG && print STDERR "$_[0]\n" }

sub run_build {
    my ( $opts, $program_name ) = @_;
    # FIXME: we should have a config dir and a function that checks
    #        for the existence of config files in it
    # FIXME: the config class should have "mandatory" fields, add checks
    my $config = readconf(
        path( $opts->{'config-base'}, "$program_name.toml" )
    );

    # double check we have the right program configuration
    my $config_name = $config->{'Package'}{'name'}
        or die "Program config must provide 'name'\n";

    my $config_category = $config->{'Package'}{'category'}
        or die "Program config must provide 'category'\n";

    $config_name eq $program_name
        or die "$program_name configuration claims it is $config_name\n";

    # FIXME: is this already built?
    # once we're done building something, we should be moving it over
    # to the "BUILT" directory (artifact repo) - then we can check if
    # a package is already available there

    # recursively build prereqs
    # starting with system libraries
    if ( my $system_prereqs = $config->{'Prereqs'}{'System'} ) {
        foreach my $prereq ( keys %{$system_prereqs} ) {
            run_build( $opts, $prereq, $system_prereqs->{$prereq} );
        }
    }

    if ( my $perl_prereqs = $config->{'Prereqs'}{'Perl'} ) {
        foreach my $prereq ( keys %{$perl_prereqs} ) {
            run_build( $opts, $prereq, $perl_prereqs->{$prereq} );
        }
    }

    my $program_src_dir = $opts->{'source-base'} . $config->{'Package'}{'directory'};

    LOG('Copying program files');
    -d $program_src_dir
        or die "Cannot find source dir: $program_src_dir\n";

    my $top_build_dir = $opts->{'build-dir'};

    my $pkgconfig_path = path( $top_build_dir, qw<main lib pkgconfig> );
    LOG("Setting PKG_CONFIG_PATH=$pkgconfig_path");
    local $ENV{'PKG_CONFIG_PATH'} = $pkgconfig_path;

    my $main_build_dir = path( $top_build_dir, 'main' );
    LOG("Setting LD_LIBRARY_PATH=$main_build_dir");
    local $ENV{'LD_LIBRARY_PATH'} = $main_build_dir;

    # FIXME: Remove in favor of a ::Build::System, ::Build::Perl, etc.
    # FIXME: $program_dst_dir is dictated from the category
    if ( $config_category eq 'system' ) {
        my $program_dst_dir = path(
            $top_build_dir,
            'libs',
            basename($program_src_dir),
        );

        dircopy( $program_src_dir, $program_dst_dir );

        print STDERR "WAS GOING TO BUILD $program_name\n";
        build_program(
            $program_name,    # zeromq
            $program_dst_dir, # /tmp/BUILD-1/libs/zeromq-1.4.1
            $main_build_dir,  # /tmp/BUILD-1/main
        ) if 0;
    } elsif ( $config_category eq 'perl' ) {
        my $program_dst_dir = path(
            $top_build_dir,
            'perl_libs',
            basename($program_src_dir),
        );

        dircopy( $program_src_dir, $program_dst_dir );

        build_perl_program(
            $program_name,    # ZMQ::Constants
            $program_dst_dir, # /tmp/BUILD-1/libs/ZMQ-Constants-...
            $main_build_dir,  # /tmp/BUILD-1/main
        );
    } else {
        die "Unrecognized category ($config_category), cannot build this.\n";
    }

    # FIXME: when to keep, when to clean up
    #        keep for now
    #LOG("Removing build dir $build_dir");
    #remove_tree($build_dir);
}

sub build_program {
    my ( $program, $build_dir, $prefix ) = @_;

    LOG("Building $program");

    my $original_dir = path('.');

    chdir $build_dir
        or die "Can't chdir to $build_dir: $!\n";

    LOG("./configure --prefix=$prefix");
    system "./configure --prefix=$prefix";

    LOG('make');
    system 'make';

    LOG('make install');
    system 'make install';

    chdir $original_dir;
    LOG("Done preparing $program");
}

sub build_perl_program {
    my ( $program, $build_dir, $prefix ) = @_;

    LOG("Building Perl module: $program");

    local $ENV{'PERL5LIB'} = join ':',
        path( $prefix, qw<share perl>, $Config{'version'} ),
        path( $prefix, qw<lib   perl>, $Config{'version'} );

    my $original_dir = path('.');

    chdir $build_dir
        or die "Can't chdir to $build_dir: $!\n";

    LOG("$^X Makefile.PL PREFIX=$prefix INSTALL_BASE=''");
    system "$^X Makefile.PL PREFIX=$prefix INSTALL_BASE=''";

    LOG('make');
    system 'make';

    LOG('make install');
    system 'make install';

    chdir $original_dir;
    LOG("Done preparing $program");
}

sub readconf {
    my $config_file = shift;
    return TOML::Parser->new( strict_mode => 1 )->parse_file($config_file);
}

sub main {
    my $opts = getopt(@ARGV);

    $opts->{'build-dir'} //= '/tmp/BUILD-' . int rand 9999;
    $opts->{'prefix-dir'}  = path( $opts->{'build-dir'}, 'main' );

    if ( ! -d ( my $dir = $opts->{'build-dir'} ) ) {
        LOG("Creating build dir $dir");
        make_path( $opts->{'prefix-dir'} ); # mkdir -p ...
    }

    run_build( $opts, $opts->{'program'} );
}

main();
